<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Habitat Designer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
   <!-- Favicon -->
    <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5;
            cursor: pointer;
            border-radius: 50%;
        }
        .slider-thumb::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5;
            cursor: pointer;
            border-radius: 50%;
        }
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(17, 24, 39, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            gap: 1.5rem;
            color: white;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #6366f1;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .level-btn.active {
            background-color: #4f46e5;
            color: white;
            border-color: #a5b4fc;
        }
        .level-btn.linking-active {
            animation: pulse-border 2s infinite;
        }
        @keyframes pulse-border {
            0%, 100% { border-color: #f59e0b; }
            50% { border-color: #fcd34d; }
        }
        .level-btn.removing-active {
            animation: pulse-border-red 1.5s infinite;
        }
        @keyframes pulse-border-red {
            0%, 100% { border-color: #ef4444; background-color: #7f1d1d; }
            50% { border-color: #fca5a5; background-color: #b91c1c; }
        }
        /* Style for draggable items */
        .module-button:active {
            cursor: grabbing;
        }
        /* Estilos adicionais para a transição do popup */
        .popup-overlay {
            transition: opacity 0.3s ease-in-out;
        }
        .popup-content {
            transition: transform 0.3s ease-in-out;
        }
        .popup-hidden {
            opacity: 0;
            pointer-events: none;
        }
        .popup-hidden .popup-content {
            transform: scale(0.95);
        }
        /* Styles from technical-analysis.html */
        .card-bg { 
          background-color: rgba(17, 24, 39, 0.8); /* Adjusted for consistency */
        }
        .danger-box { 
          background: linear-gradient(135deg, rgba(220, 38, 38, 0.2), rgba(153, 27, 27, 0.2));
          border: 1px solid rgba(220, 38, 38, 0.5);
        }
        .warning-box { 
          background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(217, 119, 6, 0.2));
          border: 1px solid rgba(245, 158, 11, 0.5);
        }
        .success-box { 
          background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(21, 128, 61, 0.2));
          border: 1px solid rgba(34, 197, 94, 0.5);
        }
        .info-box { 
          background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2));
          border: 1px solid rgba(59, 130, 246, 0.5);
        }
        .resistance-bar {
          height: 8px;
          border-radius: 4px;
          background: #374151;
          overflow: hidden;
        }
        .resistance-fill {
          height: 100%;
          transition: width 0.5s ease;
        }
        .solar-alert {
          animation: pulse 2s infinite;
        }
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.7; }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="loading-overlay">
        <div class="spinner"></div>
        <p class="text-xl">Initializing Habitat Simulation...</p>
    </div>

    <div id="app-container" class="flex h-screen w-screen opacity-0 transition-opacity duration-500">
        
        <!-- Left Control Panel -->
        <div class="w-1/4 max-w-sm h-full bg-gray-800 p-4 shadow-lg overflow-y-auto flex flex-col space-y-6">
            <div class="flex justify-between items-start">
                <div>
                    <h1 class="text-2xl font-bold text-indigo-400">Habitat Designer</h1>
                    <p class="text-sm text-gray-400">Configure your mission and habitat layout.</p>
                </div>
                <button id="back-btn" title="Go back to mission setup" class="p-2 bg-gray-700 hover:bg-indigo-600 rounded-full transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 17l-5-5m0 0l5-5m-5 5h12" />
                    </svg>
                </button>
            </div>
            
            <div class="space-y-4 bg-gray-900 p-4 rounded-lg">
                <h2 class="font-semibold text-lg border-b border-gray-700 pb-2">Mission Environment</h2>
                <div class="flex justify-around">
                    <div>
                        <input type="radio" id="env-orbit" name="environment" value="orbit" checked>
                        <label for="env-orbit" class="text-sm ml-1">Orbit / Transit</label>
                    </div>
                    <div>
                        <input type="radio" id="env-surface" name="environment" value="surface">
                        <label for="env-surface" class="text-sm ml-1">Planetary Surface</label>
                    </div>
                </div>
                <!-- Space Weather Intel Panel -->
                <div class="bg-gradient-to-r from-red-500 to-orange-500 p-3 rounded-lg mb-4" id="spaceWeatherPanel" style="display: none;">
                    <div class="flex items-center mb-2">
                        <svg class="w-5 h-5 text-white mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm.707-10.293a1 1 0 00-1.414-1.414l-3 3a1 1 0 000 1.414l3 3a1 1 0 001.414-1.414L9.414 11H13a1 1 0 100-2H9.414l1.293-1.293z" clip-rule="evenodd"></path>
                        </svg>
                        <h4 class="text-white font-bold text-sm">SPACE WEATHER ALERT</h4>
                    </div>
                    <p class="text-white text-xs mb-2" id="solarStormInfo">WARNING: Active Solar Storm Detected - Enhanced Radiation Levels</p>
                    <div class="text-white text-xs">
                        <div>Status: <span id="stormSeverity">Moderate</span></div>
                        <div>Started: <span id="stormStartTime">--</span></div>
                        <div>Type: <span id="stormType">Solar Flare</span></div>
                        <div class="mt-2 p-2 bg-black bg-opacity-30 rounded">
                            <strong>RECOMMENDATION:</strong> Ensure Storm Shelter module is included for crew protection during radiation events.
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="space-y-4 bg-gray-900 p-4 rounded-lg">
                <h2 class="font-semibold text-lg border-b border-gray-700 pb-2">Design Mode</h2>
                <div class="flex justify-around">
                    <div>
                        <input type="radio" id="mode-layout" name="design-mode" value="layout" checked>
                        <label for="mode-layout" class="text-sm ml-1">Internal Layout</label>
                    </div>
                    <div>
                        <input type="radio" id="mode-build" name="design-mode" value="build">
                        <label for="mode-build" class="text-sm ml-1">External Build</label>
                    </div>
                </div>
                 <p class="text-xs text-gray-400 mt-2">Layout: Position internal modules. Build: Move and connect entire levels.</p>
            </div>

            <div class="space-y-4 bg-gray-900 p-4 rounded-lg">
                <h2 class="font-semibold text-lg border-b border-gray-700 pb-2">Levels & Assembly</h2>
                <div id="level-selector" class="grid grid-cols-3 gap-2">
                    <!-- Level buttons will be dynamically inserted here -->
                </div>
                <div class="flex justify-center gap-2 mt-2">
                    <button id="add-level-btn" title="Add a new level to the habitat" class="w-full p-2 text-sm bg-green-600 hover:bg-green-700 rounded-md transition-colors">Add Level</button>
                    <button id="remove-level-btn" title="Remove the currently selected level" class="w-full p-2 text-sm bg-red-800 hover:bg-red-700 rounded-md transition-colors">Remove Level</button>
                </div>
                 <div class="flex justify-center gap-2 mt-4">
                      <button id="stack-levels-btn" title="Vertically stack all unlinked levels" class="w-full p-2 text-sm bg-blue-600 hover:bg-blue-700 rounded-md transition-colors">Stack All</button>
                      <button id="link-mode-btn" class="w-full p-2 text-sm bg-yellow-600 hover:bg-yellow-700 rounded-md transition-colors">Link Levels</button>
                      <button id="unlink-all-btn" class="w-full p-2 text-sm bg-red-600 hover:bg-red-700 rounded-md transition-colors">Unlink All</button>
                 </div>
            </div>

            <div class="space-y-4 bg-gray-900 p-4 rounded-lg">
                <h2 class="font-semibold text-lg border-b border-gray-700 pb-2">Gerenciamento</h2>
                <div class="flex justify-center gap-2 mt-2">
                    <button id="save-btn" title="Salva o design atual no navegador" class="w-full p-2 text-sm bg-indigo-600 hover:bg-indigo-700 rounded-md transition-colors">Salvar</button>
                    <button id="load-btn" title="Carrega um design de um arquivo" class="w-full p-2 text-sm bg-gray-600 hover:bg-gray-700 rounded-md transition-colors">Carregar</button>
                </div>
                 <div class="flex justify-center gap-2 mt-2">
                     <button id="download-btn" title="Baixa o design atual como um arquivo" class="w-full p-2 text-sm bg-green-600 hover:bg-green-700 rounded-md transition-colors">Baixar JSON</button>
                 </div>
                <input type="file" id="load-input" class="hidden" accept=".json">
            </div>

            <div class="space-y-4 bg-gray-900 p-4 rounded-lg">
                <h2 class="font-semibold text-lg border-b border-gray-700 pb-2">Structure (Active Level)</h2>
                <div>
                    <label for="habitat-shape" class="text-sm">Shape:</label>
                    <select id="habitat-shape" class="w-full mt-1 bg-gray-700 border border-gray-600 rounded-md p-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    </select>
                </div>
                <div id="dimension-controls" class="space-y-4">
                </div>
            </div>

            <div class="space-y-3 bg-gray-900 p-4 rounded-lg flex-grow">
                 <div class="flex justify-between items-center border-b border-gray-700 pb-2">
                      <h2 class="font-semibold text-lg">Functional Areas</h2>
                      <button id="clear-modules-btn" class="text-xs bg-red-600 hover:bg-red-700 px-2 py-1 rounded">Clear Modules</button>
                 </div>
                 <p class="text-xs text-gray-400 mt-2">Drag a module into the habitat to place it.</p>
                 <div id="module-palette" class="grid grid-cols-2 gap-2 pt-2">
                 </div>
            </div>
        </div>

        <!-- Center 3D Canvas -->
        <div id="canvas-container" class="flex-grow h-full relative">
            <div class="absolute top-2 left-2 bg-gray-800 bg-opacity-70 p-2 rounded-md text-xs z-10">
                <p>Controls: Left Click + Drag to Rotate | Right Click + Drag to Pan | Scroll to Zoom</p>
                <p>W: Translate | S: Scale | E: Rotate | Q/Del: Delete | ESC: Deselect</p>
                <p id="build-mode-help" class="hidden">Build Mode: Click a level to select. Link Mode: Click two levels to connect.</p>
            </div>
             <div id="link-mode-indicator" class="hidden absolute top-2 right-2 bg-yellow-500 text-black p-2 rounded-md text-sm font-bold animate-pulse z-10">
                 LINK MODE ACTIVE
             </div>
             <div id="removal-mode-indicator" class="hidden absolute top-12 right-2 bg-red-600 text-white p-2 rounded-md text-sm font-bold animate-pulse z-10">
                 SELECT LEVEL TO REMOVE
             </div>
             <!-- View Toggle Buttons -->
            <div class="absolute bottom-4 right-4 flex flex-col gap-2">
                <div id="view-dropdown" class="relative">
                    <button id="view-mode-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition-transform transform hover:scale-105 w-full flex justify-between items-center">
                        <span>3D View</span>
                        <svg class="w-4 h-4 ml-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="view-options" class="hidden absolute bottom-full mb-2 w-full bg-gray-700 rounded-lg shadow-xl z-20 overflow-hidden">
                        <a href="#" class="block px-4 py-2 text-sm text-white hover:bg-indigo-500" data-view="3d">3D View</a>
                        <a href="#" class="block px-4 py-2 text-sm text-white hover:bg-indigo-500" data-view="2d">2D View</a>
                        <a href="#" class="block px-4 py-2 text-sm text-white hover:bg-indigo-500" data-view="realistic">Realistic View</a>
                    </div>
                </div>
                <button id="reset-camera-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition-transform transform hover:scale-105">
                     Reset View
                </button>
            </div>
        </div>

        <!-- Right Analysis Panel -->
        <div class="w-1/4 max-w-sm h-full bg-gray-800 p-4 shadow-lg overflow-y-auto flex flex-col space-y-6">
            <div class="flex justify-between items-start">
                <div>
                    <h2 class="text-xl font-bold text-indigo-400">System Analysis</h2>
                    <p class="text-sm text-gray-400">Real-time design feedback.</p>
                </div>
                <button id="summary-btn" title="Abrir resumo técnico" class="p-2 bg-gray-700 hover:bg-indigo-600 rounded-full transition-colors flex-shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                </button>
            </div>

            <!-- Space Weather Intel Panel -->
            <div class="bg-gradient-to-r from-red-500 to-orange-500 p-3 rounded-lg mb-4" id="spaceWeatherPanel" style="display: none;">
                <div class="flex items-center mb-2">
                    <svg class="w-5 h-5 text-white mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm.707-10.293a1 1 0 00-1.414-1.414l-3 3a1 1 0 000 1.414l3 3a1 1 0 001.414-1.414L9.414 11H13a1 1 0 100-2H9.414l1.293-1.293z" clip-rule="evenodd"></path>
                    </svg>
                    <h4 class="text-white font-bold text-sm">SPACE WEATHER ALERT</h4>
                </div>
                <p class="text-white text-xs mb-2" id="solarStormInfo">WARNING: Active Solar Storm Detected - Enhanced Radiation Levels</p>
                <div class="text-white text-xs">
                    <div>Status: <span id="stormSeverity">Moderate</span></div>
                    <div>Started: <span id="stormStartTime">--</span></div>
                    <div>Type: <span id="stormType">Solar Flare</span></div>
                    <div class="mt-2 p-2 bg-black bg-opacity-30 rounded">
                        <strong>RECOMMENDATION:</strong> Ensure Storm Shelter module is included for crew protection during radiation events.
                    </div>
                </div>
            </div>
            
            <div class="bg-gray-900 p-4 rounded-lg">
                <h3 class="font-semibold text-lg border-b border-gray-700 pb-2">Habitat Totals</h3>
                <div class="text-sm space-y-2 mt-2">
                    <p>Total Volume: <span id="total-volume" class="font-mono text-green-400">0 m³</span></p>
                    <p>Pressurized Volume: <span id="pressurized-volume" class="font-mono text-green-400">0 m³</span></p>
                    <p>Modules Added: <span id="modules-count" class="font-mono text-green-400">0</span></p>
                </div>
            </div>
            
            <div id="oxygen-analysis" class="bg-gray-900 p-4 rounded-lg">
                <h3 class="font-semibold text-lg border-b border-gray-700 pb-2 text-blue-400">Oxygen Analysis</h3>
                <div class="text-sm space-y-2 mt-2">
                    <p>Crew Members: <span id="oxygen-crew-size" class="font-mono text-white">0</span></p>
                    <p>Required O₂ Production: <span id="oxygen-required" class="font-mono text-white">0 L/day</span></p>
                </div>
            </div>

            <div id="engineering-rationale" class="bg-gray-900 p-4 rounded-lg hidden">
                <h3 class="font-semibold text-lg border-b border-gray-700 pb-2 text-green-400">Engineering Rationale</h3>
                <div class="text-sm space-y-2 mt-2">
                    <p>Shape: <strong id="rationale-shape" class="font-mono text-white">N/A</strong></p>
                    <p id="rationale-text" class="text-gray-300">Select a habitat level in Build Mode to see the structural rationale.</p>
                </div>
            </div>

            <div id="selected-module-info" class="bg-gray-900 p-4 rounded-lg hidden">
                <h3 class="font-semibold text-lg border-b border-gray-700 pb-2">Selected: <span id="selected-module-name"></span></h3>
                <div class="text-sm space-y-2 mt-2">
                    <p>Volume: <span id="selected-module-volume" class="font-mono">0 m³</span></p>
                    <p>Required: <span id="selected-module-required" class="font-mono">0 m³</span></p>
                    <p>Status: <span id="selected-module-status" class="font-bold">N/A</span></p>
                </div>
                <button id="delete-module-btn" class="w-full mt-3 p-2 text-sm bg-red-600 hover:bg-red-700 rounded-md transition-colors">Delete Module</button>
            </div>

            <div id="mission-checklist" class="bg-gray-900 p-4 rounded-lg">
                <h3 class="font-semibold text-lg border-b border-gray-700 pb-2 text-cyan-400">Readiness Checklist</h3>
                <ul id="checklist-list" class="text-sm space-y-2 mt-2">
                </ul>
            </div>
            
             <div class="bg-gray-900 p-4 rounded-lg flex-grow">
                 <h3 class="font-semibold text-lg border-b border-gray-700 pb-2 text-yellow-400">Alerts & Warnings</h3>
                 <ul id="alerts-list" class="text-sm space-y-2 mt-2 list-disc list-inside">
                       <li class="text-gray-500">No alerts at this time.</li>
                 </ul>
             </div>
        </div>
    </div>

    <!-- O Popup (Modal) para o Resumo Técnico -->
    <div id="summaryPopupOverlay" class="popup-overlay popup-hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
        <!-- Conteúdo do Popup -->
        <div id="summaryPopupContent" class="popup-content bg-gray-800 text-white rounded-lg shadow-2xl p-6 max-w-7xl w-full h-[90vh] relative border border-indigo-500 flex flex-col">
            <!-- Botão para fechar o popup -->
            <button id="closeSummaryPopupBtn" class="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl font-bold z-20">&times;</button>
            
            <!-- Header do Popup -->
            <div class="flex-shrink-0 mb-4 border-b border-gray-700 pb-4">
                 <h1 class="text-3xl font-bold text-indigo-400">Mission Technical Analysis</h1>
                 <p class="text-gray-300 mt-1" id="popup-mission-summary">Loading mission profile...</p>
            </div>

            <!-- Conteúdo da Análise (scrollable) -->
            <div id="analysis-content" class="flex-grow overflow-y-auto pr-4 -mr-2">
                 <div class="grid lg:grid-cols-2 gap-6">
                    <!-- ANÁLISE DE SOBREVIVÊNCIA POR DESTINO -->
                    <div class="card-bg p-6 rounded-2xl shadow-xl">
                        <h2 class="text-xl font-semibold mb-4 border-b border-gray-600 pb-2 flex items-center gap-2">
                            <i data-lucide="target" class="w-5 h-5 text-indigo-400"></i>
                            Survival Analysis - <span id="popup-destination-name">Destination</span>
                        </h2>
                        <div id="popup-destination-analysis" class="space-y-4"></div>
                    </div>
                    <!-- MATERIAL ANALYSIS -->
                    <div class="card-bg p-6 rounded-2xl shadow-xl">
                        <h2 class="text-xl font-semibold mb-4 border-b border-gray-600 pb-2 flex items-center gap-2">
                            <i data-lucide="shield" class="w-5 h-5 text-indigo-400"></i>
                            Habitat Material Analysis
                        </h2>
                        <div id="popup-material-analysis" class="space-y-4"></div>
                    </div>
                </div>
                 <div class="grid lg:grid-cols-1 gap-6 mt-6">
                    <!-- ANÁLISE DE ARQUITETURA -->
                    <div class="card-bg p-6 rounded-2xl shadow-xl">
                        <h2 class="text-xl font-semibold mb-4 border-b border-gray-600 pb-2 flex items-center gap-2">
                            <i data-lucide="settings" class="w-5 h-5 text-indigo-400"></i>
                            Mission Architecture Analysis
                        </h2>
                        <div class="grid md:grid-cols-2 gap-6">
                            <div id="popup-propulsion-analysis"></div>
                            <div id="popup-habitat-strategy-analysis"></div>
                        </div>
                    </div>
                </div>
                 <!-- MONITORAMENTO SOLAR EM TEMPO REAL -->
                <div class="card-bg p-6 rounded-2xl shadow-xl mt-6">
                    <h2 class="text-xl font-semibold mb-4 border-b border-gray-600 pb-2 flex items-center gap-2">
                        <i data-lucide="sun" class="w-5 h-5 text-yellow-400"></i>
                        Solar Threat Monitoring - DONKI API
                    </h2>
                    <div id="popup-solar-monitoring" class="space-y-4">
                        <div class="info-box p-4 rounded-lg">
                            <div class="flex items-center gap-3 mb-3">
                                <i data-lucide="satellite" class="w-6 h-6 text-blue-400"></i>
                                <h3 class="font-semibold">Monitoring System Status</h3>
                            </div>
                            <p class="text-sm text-gray-300 mb-3">
                                System connected to NASA's DONKI API for real-time monitoring of:
                            </p>
                            <div class="grid md:grid-cols-3 gap-3 text-xs">
                                <div class="bg-gray-900/50 p-3 rounded">
                                    <strong class="text-orange-400">CME</strong>
                                    <p>Coronal Mass Ejections</p>
                                </div>
                                <div class="bg-gray-900/50 p-3 rounded">
                                    <strong class="text-red-400">FLR</strong>
                                    <p>Solar Flares</p>
                                </div>
                                <div class="bg-gray-900/50 p-3 rounded">
                                    <strong class="text-purple-400">SEP</strong>
                                    <p>Solar Proton Events</p>
                                </div>
                            </div>
                        </div>
                        <div id="popup-solar-events" class="space-y-3">
                            <div class="flex items-center justify-center p-4 text-gray-400">
                                <i data-lucide="loader" class="w-5 h-5 animate-spin mr-2"></i>
                                Loading solar activity data...
                            </div>
                        </div>
                    </div>
                </div>
                 <!-- ANÁLISE DE RISCOS E RECOMENDAÇÕES -->
                <div class="card-bg p-6 rounded-2xl shadow-xl mt-6 mb-8" id="popup-risk-analysis">
                    <h2 class="text-xl font-semibold mb-4 border-b border-gray-600 pb-2 flex items-center gap-2">
                        <i data-lucide="alert-triangle" class="w-5 h-5 text-yellow-400"></i>
                        Risk Analysis & Recommendations
                    </h2>
                    <div id="popup-recommendations" class="space-y-4"></div>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // NASA DONKI Space Weather API Integration - Production Ready
        const DONKI_API_BASE = 'https://api.nasa.gov/DONKI';
        const NASA_API_KEY = 'DEMO_KEY'; // Replace with actual API key for production
        
        async function fetchActiveSpaceWeatherEvents() {
            try {
                const endDate = new Date();
                const startDate = new Date(endDate.getTime() - (7 * 24 * 60 * 60 * 1000)); // Last 7 days
                
                const endpoints = [
                    `${DONKI_API_BASE}/FLR?startDate=${startDate.toISOString().split('T')[0]}&endDate=${endDate.toISOString().split('T')[0]}&api_key=${NASA_API_KEY}`,
                    `${DONKI_API_BASE}/SEP?startDate=${startDate.toISOString().split('T')[0]}&endDate=${endDate.toISOString().split('T')[0]}&api_key=${NASA_API_KEY}`,
                    `${DONKI_API_BASE}/CME?startDate=${startDate.toISOString().split('T')[0]}&endDate=${endDate.toISOString().split('T')[0]}&api_key=${NASA_API_KEY}`
                ];
                
                const responses = await Promise.all(endpoints.map(url => 
                    fetch(url).then(res => res.json()).catch(() => [])
                ));
                
                const [flares, seps, cmes] = responses;
                return { flares: flares || [], seps: seps || [], cmes: cmes || [] };
            } catch (error) {
                console.warn('Space Weather API Error:', error);
                return { flares: [], seps: [], cmes: [] };
            }
        }

        // --- Technical Analysis Data & Functions (Integrated) ---

        const destinationData = {
          'Orbit': {
            name: 'Earth Orbit',
            description: 'Microgravity environment for stations or transit vehicles',
            threats: {
              radiation: { level: 'EXTREME', description: 'Full exposure to GCR and SPE' },
              microgravity: { level: 'EXTREME', description: 'Severe physiological degradation' },
              temperature: { level: 'MODERATE', description: 'Variations due to orbital cycles' }
            },
            resources: 'None - 100% dependent on resupply',
            advantages: ['Constant solar energy', 'Easy modular construction'],
            disadvantages: ['Health effects', 'Total Earth dependency']
          },
          'Moon': {
            name: 'Moon',
            description: 'Rocky body without atmosphere, 3 days from Earth',
            threats: {
              radiation: { level: 'EXTREME', description: 'No atmospheric or magnetic protection' },
              temperature: { level: 'EXTREME', description: 'Variation from +120°C to -170°C' },
              dust: { level: 'HIGH', description: 'Fine and sharp regolith' }
            },
            resources: 'Polar ice, Regolith for construction, Intermittent sunlight (14 days)',
            advantages: ['Earth proximity (logistics and rescue)', 'Partial gravity (1/6 g)'],
            disadvantages: ['14-day night', 'Dust hazard', 'Surface radiation']
          },
          'Mars': {
            name: 'Mars',
            description: 'Rocky planet with thin atmosphere, 6-9 months from Earth',
            threats: {
              radiation: { level: 'HIGH', description: 'Thin atmosphere offers minimal protection' },
              dust_storms: { level: 'HIGH', description: 'Can last weeks, blocking sunlight' },
              temperature: { level: 'HIGH', description: 'Average temperature -63°C' }
            },
            resources: 'Abundant subsurface ice, CO₂ atmosphere, Rich minerals',
            advantages: ['Maximum self-sufficiency potential', '24.5h day/night cycle', 'Favorable gravity (1/3 g)'],
            disadvantages: ['Extreme distance (no rescue)', 'Communication delay (up to 22 min)', 'Dust storms']
          }
        };

        const materialData = {
          'aluminum': {
            name: 'Aluminum Alloy',
            description: 'Aerospace standard (Al 2219)',
            resistance: { radiation: 4, thermal: 7, abrasion: 6 },
            advantages: ['Lightweight', 'Inexpensive', 'Easy fabrication', 'Well understood'],
            disadvantages: ['Poor radiation shielding', 'Susceptible to thermal cycle fatigue']
          },
          'titanium': {
            name: 'Titanium Composite',
            description: 'Fiber-reinforced alloys',
            resistance: { radiation: 5, thermal: 9, abrasion: 8 },
            advantages: ['Extremely strong', 'Corrosion resistant', 'High temperatures'],
            disadvantages: ['Expensive and heavy', 'Difficult fabrication and repair']
          },
          'carbon_fiber': {
            name: 'Carbon Fiber',
            description: 'Polymer matrix with fibers',
            resistance: { radiation: 3, thermal: 8, abrasion: 7 },
            advantages: ['Exceptional strength/weight ratio', 'Very rigid'],
            disadvantages: ['Radiation creates dangerous secondary particles', 'Difficult repair']
          },
          'regolith_3d': {
            name: '3D Printed Regolith',
            description: 'Laser/microwave sintered soil',
            resistance: { radiation: 10, thermal: 9, abrasion: 4 },
            advantages: ['Exceptional shielding', 'Local resources (zero mass)', 'Excellent thermal insulator'],
            disadvantages: ['Brittle', 'Low tensile strength', 'Vulnerable to impacts']
          },
          'polyethylene': {
            name: 'Polyethylene',
            description: 'Hydrogen-rich plastic',
            resistance: { radiation: 9, thermal: 5, abrasion: 3 },
            advantages: ['Excellent GCR and neutron shielding', 'Lightweight'],
            disadvantages: ['Structurally weak', 'Internal shielding only']
          }
        };

        function generatePopupDestinationAnalysis(missionData) {
          const dest = destinationData[missionData.destination];
          if (!dest) return;

          document.getElementById('popup-destination-name').textContent = dest.name;
          
          const analysisHtml = `
            <div class="info-box p-4 rounded-lg mb-4">
              <p class="text-blue-300 font-medium mb-2">${dest.description}</p>
            </div>
            <div class="space-y-3">
              <h4 class="font-semibold text-red-300 flex items-center gap-2">
                <i data-lucide="alert-triangle" class="w-4 h-4"></i>Identified Threats
              </h4>
              ${Object.entries(dest.threats).map(([type, threat]) => `
                <div class="danger-box p-3 rounded">
                  <div class="flex justify-between items-center mb-1">
                    <span class="font-medium capitalize">${type.replace('_', ' ')}</span>
                    <span class="text-xs px-2 py-1 rounded ${
                      threat.level === 'EXTREME' ? 'bg-red-600' : 
                      threat.level === 'HIGH' ? 'bg-orange-600' : 'bg-yellow-600'
                    }">${threat.level}</span>
                  </div>
                  <p class="text-sm text-gray-300">${threat.description}</p>
                </div>
              `).join('')}
            </div>
            <div class="mt-4">
              <h4 class="font-semibold text-yellow-300 mb-2">Available ISRU Resources</h4>
              <div class="warning-box p-3 rounded">
                <p class="text-sm">${dest.resources}</p>
              </div>
            </div>
            <div class="grid md:grid-cols-2 gap-4 mt-4">
              <div class="success-box p-3 rounded">
                <h5 class="font-semibold text-green-300 mb-2">Advantages</h5>
                <ul class="text-sm space-y-1">
                  ${dest.advantages.map(adv => `<li class="flex items-start gap-2"><i data-lucide="check" class="w-3 h-3 mt-0.5 text-green-400"></i>${adv}</li>`).join('')}
                </ul>
              </div>
              <div class="danger-box p-3 rounded">
                <h5 class="font-semibold text-red-300 mb-2">Disadvantages</h5>
                <ul class="text-sm space-y-1">
                  ${dest.disadvantages.map(dis => `<li class="flex items-start gap-2"><i data-lucide="x" class="w-3 h-3 mt-0.5 text-red-400"></i>${dis}</li>`).join('')}
                </ul>
              </div>
            </div>
          `;
          document.getElementById('popup-destination-analysis').innerHTML = analysisHtml;
        }

        function generatePopupMaterialAnalysis(missionData) {
          const material = materialData[missionData.habitat_material];
          if (!material) return;

          const analysisHtml = `
            <div class="info-box p-4 rounded-lg mb-4">
              <h3 class="font-semibold text-blue-300 mb-2">${material.name}</h3>
              <p class="text-sm text-gray-300">${material.description}</p>
            </div>
            <div class="space-y-3">
              <h4 class="font-semibold mb-3">Material Resistance</h4>
              ${Object.entries(material.resistance).map(([type, value]) => `
                <div class="flex items-center justify-between mb-2">
                  <span class="text-sm capitalize">${type}</span>
                  <div class="flex items-center gap-2">
                    <div class="resistance-bar w-24">
                      <div class="resistance-fill ${value >= 8 ? 'bg-green-500' : value >= 6 ? 'bg-yellow-500' : value >= 4 ? 'bg-orange-500' : 'bg-red-500'}" 
                           style="width: ${value * 10}%"></div>
                    </div>
                    <span class="text-sm font-mono w-8">${value}/10</span>
                  </div>
                </div>
              `).join('')}
            </div>
            <div class="grid md:grid-cols-1 gap-4 mt-4">
              <div class="success-box p-3 rounded">
                <h5 class="font-semibold text-green-300 mb-2">Advantages</h5>
                <ul class="text-sm space-y-1">
                  ${material.advantages.map(adv => `<li class="flex items-start gap-2"><i data-lucide="plus" class="w-3 h-3 mt-0.5 text-green-400"></i>${adv}</li>`).join('')}
                </ul>
              </div>
              <div class="danger-box p-3 rounded mt-2">
                <h5 class="font-semibold text-red-300 mb-2">Disadvantages</h5>
                <ul class="text-sm space-y-1">
                  ${material.disadvantages.map(dis => `<li class="flex items-start gap-2"><i data-lucide="minus" class="w-3 h-3 mt-0.5 text-red-400"></i>${dis}</li>`).join('')}
                </ul>
              </div>
            </div>
          `;
          document.getElementById('popup-material-analysis').innerHTML = analysisHtml;
        }
        
        function generatePopupArchitectureAnalysis(missionData) {
          const propulsionHtml = `
            <div class="info-box p-4 rounded-lg h-full">
              <h3 class="font-semibold text-blue-300 mb-3 flex items-center gap-2">
                <i data-lucide="rocket" class="w-4 h-4"></i>
                Propulsion System: ${missionData.propulsion === 'nuclear' ? 'Nuclear Thermal' : 'Chemical'}
              </h3>
              ${missionData.propulsion === 'nuclear' ? `...` : `...`}
            </div>
          `;
          const strategyNames = { 'pre_fabricated': 'Pre-fabricated', 'inflatable': 'Inflatable Modules', 'isru_printed': '3D Printed (ISRU)' };
          const habitatHtml = `
            <div class="info-box p-4 rounded-lg h-full">
              <h3 class="font-semibold text-blue-300 mb-3 flex items-center gap-2">
                <i data-lucide="home" class="w-4 h-4"></i>
                Strategy: ${strategyNames[missionData.habitat_strategy] || missionData.habitat_strategy}
              </h3>
              ${missionData.habitat_strategy === 'isru_printed' ? `...` : `...`}
            </div>
          `;
          document.getElementById('popup-propulsion-analysis').innerHTML = propulsionHtml;
          document.getElementById('popup-habitat-strategy-analysis').innerHTML = habitatHtml;
        }

        function generatePopupRiskAnalysis(missionData) {
            const destination = destinationData[missionData.destination];
            const material = materialData[missionData.habitat_material];
            const hasStormShelter = missionData.storm_shelter === 'true';
            
            let riskLevel = 'MODERATE';
            let recommendations = [];
            
            if (destination?.threats.radiation?.level === 'EXTREME' && material?.resistance.radiation < 6) {
                riskLevel = 'CRITICAL';
                recommendations.push({ type: 'critical', title: 'Insufficient Radiation Shielding', description: `Material ${material.name} offers inadequate protection (${material.resistance.radiation}/10) for ${destination.threats.radiation.level} radiation environment.`, action: 'Consider using 3D Regolith or adding Polyethylene layers.'});
            }
            if (!hasStormShelter && destination?.threats.radiation) {
                recommendations.push({ type: 'warning', title: 'Storm Shelter Recommended', description: 'Without additional protection, solar storms can be fatal.', action: 'Add a shelter with extra shielding (water or polyethylene).'});
            }
            if (missionData.propulsion === 'chemical' && missionData.destination === 'Mars') {
                recommendations.push({ type: 'warning',  title: 'Prolonged Radiation Exposure', description: '6-9 month journey with chemical propulsion significantly increases radiation dose.', action: 'Consider nuclear thermal propulsion to reduce travel time.'});
            }
            if (material?.name === 'Carbon Fiber') {
                recommendations.push({ type: 'info', title: 'Secondary Particles', description: 'Carbon fiber can generate dangerous secondary particles when hit by radiation.', action: 'Add internal polyethylene layer to capture particles.' });
            }
            
            const recommendationsHtml = `
                <div class="mb-4"><div class="flex items-center gap-3 mb-3">
                <div class="w-3 h-3 rounded-full ${riskLevel === 'CRITICAL' ? 'bg-red-500' : 'bg-yellow-500'}"></div>
                <span class="font-semibold">Overall Risk Level: ${riskLevel}</span></div></div>
                <div class="space-y-4">
                ${recommendations.map(rec => `<div class="${rec.type === 'critical' ? 'danger-box' : rec.type === 'warning' ? 'warning-box' : 'info-box'} p-4 rounded-lg"><div class="flex items-start gap-3"><i data-lucide="${rec.type === 'critical' ? 'alert-circle' : rec.type === 'warning' ? 'alert-triangle' : 'info'}" class="w-5 h-5 mt-0.5 ${rec.type === 'critical' ? 'text-red-400' : rec.type === 'warning' ? 'text-yellow-400' : 'text-blue-400'}"></i><div><h4 class="font-semibold mb-2">${rec.title}</h4><p class="text-sm text-gray-300 mb-2">${rec.description}</p><p class="text-sm font-medium"><strong>Recommended Action:</strong> ${rec.action}</p></div></div></div>`).join('')}
                </div>
                ${hasStormShelter ? `<div class="success-box p-4 rounded-lg mt-4"><div class="flex items-center gap-3"><i data-lucide="shield-check" class="w-5 h-5 text-green-400"></i><div><h4 class="font-semibold text-green-300">Storm Shelter Configured</h4><p class="text-sm text-gray-300">Type: ${missionData.shelter_type.replace('_',' ')}</p></div></div></div>` : ''}
            `;
            document.getElementById('popup-recommendations').innerHTML = recommendationsHtml;
        }

        function simulatePopupSolarMonitoring() {
            setTimeout(() => {
                const events = [{ type: 'CME', time: '2025-10-04T14:30:00Z', severity: 'Moderate', description: 'Moderate velocity coronal mass ejection detected', impact: 'Arrival expected in 48-72 hours'}, { type: 'FLR', time: '2025-10-04T08:15:00Z', severity: 'C-Class', description: 'C-class solar flare detected', impact: 'Radiation arrived in 8 minutes - no critical risk'}];
                document.getElementById('popup-solar-events').innerHTML = events.map(event => `<div class="${event.severity === 'Moderate' ? 'warning-box' : 'info-box'} p-4 rounded-lg"><div class="flex items-start justify-between"><div class="flex items-start gap-3"><i data-lucide="${event.type === 'CME' ? 'zap' : 'sun'}" class="w-5 h-5 mt-0.5 ${event.type === 'CME' ? 'text-orange-400' : 'text-yellow-400'}"></i><div><h4 class="font-semibold mb-1">${event.type} - ${event.severity}</h4><p class="text-sm text-gray-300 mb-1">${event.description}</p><p class="text-xs text-gray-400">${event.impact}</p></div></div><span class="text-xs text-gray-400">${new Date(event.time).toLocaleString()}</span></div></div>`).join('');
            }, 1000);
        }
        
        // --- Popup Logic ---
        const summaryPopupOverlay = document.getElementById('summaryPopupOverlay');

        function openSummaryPopup() {
            const destinationMap = { 'orbit': 'Orbit', 'surface': 'Mars' };
            const missionProfile = {
                destination: destinationMap[missionParams.environment] || 'Orbit',
                passengers: missionParams.crewSize,
                duration: missionParams.duration,
                habitat_material: 'aluminum', 
                propulsion: 'chemical',
                habitat_strategy: 'pre_fabricated',
                storm_shelter: 'true',
                shelter_type: 'water_walls'
            };

            const destination = destinationData[missionProfile.destination]?.name || missionProfile.destination;
            document.getElementById('popup-mission-summary').innerHTML = `${missionProfile.passengers} crew members • ${missionProfile.duration} days • Destination: ${destination}`;
            
            generatePopupDestinationAnalysis(missionProfile);
            generatePopupMaterialAnalysis(missionProfile);
            generatePopupArchitectureAnalysis(missionProfile);
            generatePopupRiskAnalysis(missionProfile);
            simulatePopupSolarMonitoring();
            
            summaryPopupOverlay.classList.remove('popup-hidden');
            lucide.createIcons();
        }

        function closeSummaryPopup() {
            summaryPopupOverlay.classList.add('popup-hidden');
        }


        // --- Configuration Data ---
        const MODULE_TYPES = {
            'Crew Quarters': { color: 0x1d4ed8, volumePerCrew: 7, adjacencyWarning: ['Exercise', 'Workshop', 'ECLSS'] },
            'Hygiene': { color: 0x0e7490, volumePerCrew: 4, adjacencyWarning: ['Galley'] },
            'Galley': { color: 0x0ca5e9, volumePerCrew: 6, adjacencyWarning: ['Hygiene', 'Waste Management'] },
            'Exercise': { color: 0xbe123c, volumePerCrew: 8, adjacencyWarning: ['Crew Quarters'] },
            'Recreation': { color: 0xd9463f, volumePerCrew: 9, adjacencyWarning: [] },
            'Storage': { color: 0x64748b, volumePerCrew: 10, missionDurationFactor: 0.1, adjacencyWarning: [] },
            'Workshop': { color: 0xd97706, volumePerCrew: 5, adjacencyWarning: ['Crew Quarters'] },
            'ECLSS': { color: 0x7c2d12, volumePerCrew: 10, adjacencyWarning: ['Crew Quarters', 'Galley'] },
            'Waste Management': { color: 0x4a044e, volumePerCrew: 3, adjacencyWarning: ['Galley', 'Hygiene'] },
            'Science Lab': { color: 0x059669, volumePerCrew: 12, adjacencyWarning: [] },
            'Greenhouse': { color: 0x16a34a, volumePerCrew: 8, adjacencyWarning: ['Waste Management'] },
            'Airlock': { color: 0x9ca3af, volumePerCrew: 2, adjacencyWarning: [] },
            'Storm Shelter': {
                color: 0x991b1b,
                volumePerCrew: 2,
                description: 'Radiation-shielded emergency shelter for solar storm protection',
                shieldingFactor: 0.9,
                emergencySupplyDays: 3,
                adjacencyPreference: ['Crew Quarters', 'Medical Bay'],
                requiredForEnvironments: ['orbit', 'surface'],
                criticalForSpaceWeather: true,
                adjacencyWarning: []
            },
        };

        const MODULE_ICONS = {
            'Crew Quarters': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 14v3m4-3v3m4-3v3M3 21h18M3 10h18M3 7l9-4 9 4M4 10h16v11H4V10z" /></svg>`,
            'Hygiene': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-12v4m-2-2h4m6 4v4m-2-2h4M6 21a2 2 0 002-2h8a2 2 0 002-2V7a2 2 0 00-2-2h-4M6 21V7a2 2 0 012-2h4" /></svg>`,
            'Galley': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7.014A8.003 8.003 0 0112 2a8.003 8.003 0 016.014 2.986C20.5 5 21 8 21 10c2 1 2.657 1.343 2.657 2.657a8 8 0 01-1.343 5.657z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>`,
            'Exercise': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>`,
            'Recreation': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`,
            'Storage': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4M4 7s0 0 0 0m16 0s0 0 0 0M12 11a4 4 0 100-8 4 4 0 000 8z" /></svg>`,
            'Workshop': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>`,
            'ECLSS': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h5M5 5a7 7 0 0110.606.394M20 20v-5h-5m-1-1a7 7 0 01-10.606-.394" /></svg>`,
            'Waste Management': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>`,
            'Science Lab': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547a2 2 0 00-.547 1.806l.477 2.387a6 6 0 00.517 3.86l.158.318a6 6 0 003.86.517l2.387.477a2 2 0 001.806-.547a2 2 0 00.547-1.806l-.477-2.387a6 6 0 00-.517-3.86l-.158-.318z" /><path stroke-linecap="round" stroke-linejoin="round" d="M14.25 10.25l1.5 1.5m0 0l-1.5 1.5m1.5-1.5h-3m-6 0l-1.5-1.5m0 0l1.5-1.5m-1.5 1.5h3" /></svg>`,
            'Greenhouse': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14.121 15.879A3 3 0 0112.025 18a3 3 0 01-2.096-2.121m0 0A3 3 0 0012.025 12a3 3 0 002.096-2.121m-4.192 0A3 3 0 0112.025 6a3 3 0 012.096 2.121m0 0A3 3 0 0016.12 12a3 3 0 00-2.096 2.121" /></svg>`,
            'Airlock': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" /></svg>`,
            'Storm Shelter': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M20.618 5.984A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016zM12 7v5l-3 3" /></svg>`,
            'default': `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-1 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" /></svg>`
        };
        
        const HABITAT_SHAPES = {
            orbit: { 
                'Cylindrical Module': 'cylinder', 
                'Inflatable Module': 'inflatable', 
                'Rotational Station (Torus)': 'torus',
                'Spindle Module': 'spindle',
                'Hexagonal Prism': 'hexagon',
                'Truss Structure': 'truss',
            },
            surface: { 
                'Cylindrical Module': 'cylinder', 
                'Inflatable Module': 'inflatable', 
                'Planetary Base (Dome)': 'dome', 
                'Connector Module': 'connector',
                'Hexagonal Prism': 'hexagon',
                'Saucer Base': 'saucer',
            }
        };

        const SHAPE_RATIONALES = {
            'cylinder': 'Excellent for containing internal pressure. Maximizes usable volume within rocket fairing limitations, making it a common choice for orbital modules.',
            'inflatable': 'Provides a massive pressurized volume for a very small launch mass and size. The flexible fabric becomes rigid when inflated, ideal for large living areas on long missions.',
            'torus': 'Designed to generate artificial gravity through rotation (centripetal force). This is crucial for mitigating the long-term negative health effects of microgravity on the crew.',
            'dome': 'Geodesic domes are incredibly strong for their weight, distributing stress efficiently. They are ideal for planetary surfaces, resisting gravity and atmospheric pressure while providing a large, open interior space.',
            'connector': 'While less efficient for pressure, its rectangular shape is perfect for modularity. It allows for the easy connection between other modules to build complex surface bases with defined interior spaces.',
            'hexagon': 'Structurally efficient and ideal for tessellation, allowing multiple modules to connect seamlessly with no wasted space, forming larger, integrated complexes.',
            'spindle': 'An elongated, often cylindrical or tapered shape optimized for in-space transit, potentially housing propulsion systems, fuel, or long corridors connecting habitat sections.',
            'truss': 'A non-pressurized backbone structure, essential for mounting large components like solar arrays, radiators, and external modules on large space stations. Provides structural integrity over long distances.',
            'saucer': 'Offers a large, continuous floor area for a given height, making it very stable on planetary surfaces. Its shape is efficient for resisting atmospheric pressure if present.'
        };

        const ESSENTIAL_MODULES = ['Crew Quarters', 'Hygiene', 'Galley', 'ECLSS', 'Recreation', 'Storage'];
        const OXYGEN_PER_PERSON_L_DAY = 588;
        const ACTIVE_SHELL_COLOR = 0x4a5568;
        const COMPLETED_SHELL_COLOR = 0xd1d5db;
        const INITIAL_CAMERA_POS = new THREE.Vector3(20, 20, 25);

        // --- Core Three.js Components ---
        let scene, renderer, orbitControls, transformControls, raycaster;
        let perspectiveCamera, orthographicCamera, activeCamera;
        let connectionsGroup, placementGrid;
        const pointer = new THREE.Vector2();
        let groundPlane, surfaceFeatures;
        const internalModules = [];
        const clippingPlanes = [ new THREE.Plane(new THREE.Vector3(0, -1, 0), 0) ];

        // --- DOM Elements ---
        const canvasContainer = document.getElementById('canvas-container');
        const habitatShapeSelect = document.getElementById('habitat-shape');
        const totalVolumeEl = document.getElementById('total-volume');
        const pressurizedVolumeEl = document.getElementById('pressurized-volume');
        const modulesCountEl = document.getElementById('modules-count');
        const selectedModuleInfoEl = document.getElementById('selected-module-info');
        const selectedModuleNameEl = document.getElementById('selected-module-name');
        const selectedModuleVolumeEl = document.getElementById('selected-module-volume');
        const selectedModuleRequiredEl = document.getElementById('selected-module-required');
        const selectedModuleStatusEl = document.getElementById('selected-module-status');
        const alertsListEl = document.getElementById('alerts-list');
        const checklistListEl = document.getElementById('checklist-list');
        const oxygenCrewSizeEl = document.getElementById('oxygen-crew-size');
        const oxygenRequiredEl = document.getElementById('oxygen-required');
        const engineeringRationaleEl = document.getElementById('engineering-rationale');
        const rationaleShapeEl = document.getElementById('rationale-shape');
        const rationaleTextEl = document.getElementById('rationale-text');
        const buildModeHelp = document.getElementById('build-mode-help');
        const resetCameraBtn = document.getElementById('reset-camera-btn');

        // --- State ---
        let missionParams = { crewSize: 4, duration: 365, environment: 'orbit' };
        
        // Space Weather Monitoring State
        let isSolarStormActive = false;
        let currentSpaceWeatherData = null;
        let spaceWeatherCheckInterval = null;
        
        async function checkSpaceWeather() {
            const weatherData = await fetchActiveSpaceWeatherEvents();
            const now = new Date();
            
            // Check for active events (within last 24 hours for flares, 72 hours for CMEs/SEPs)
            const activeFlares = weatherData.flares.filter(flare => {
                const eventTime = new Date(flare.beginTime || flare.peakTime);
                const hoursSinceEvent = (now - eventTime) / (1000 * 60 * 60);
                return hoursSinceEvent <= 24 && (flare.classType?.includes('X') || flare.classType?.includes('M'));
            });
            
            const activeSEPs = weatherData.seps.filter(sep => {
                const eventTime = new Date(sep.eventTime);
                const hoursSinceEvent = (now - eventTime) / (1000 * 60 * 60);
                return hoursSinceEvent <= 72;
            });
            
            const activeCMEs = weatherData.cmes.filter(cme => {
                const eventTime = new Date(cme.activityID?.split('-')[0] + 'T00:00:00Z');
                const hoursSinceEvent = (now - eventTime) / (1000 * 60 * 60);
                return hoursSinceEvent <= 72;
            });
            
            const hasActiveEvents = activeFlares.length > 0 || activeSEPs.length > 0 || activeCMEs.length > 0;
            
            if (hasActiveEvents !== isSolarStormActive) {
                isSolarStormActive = hasActiveEvents;
                currentSpaceWeatherData = { flares: activeFlares, seps: activeSEPs, cmes: activeCMEs };
                updateSpaceWeatherUI();
                runAnalysis(); // Re-run analysis when storm status changes
            }
        }
        
        function updateSpaceWeatherUI() {
            const panel = document.getElementById('spaceWeatherPanel');
            const stormInfo = document.getElementById('solarStormInfo');
            const severity = document.getElementById('stormSeverity');
            const startTime = document.getElementById('stormStartTime');
            const stormType = document.getElementById('stormType');
            
            if (isSolarStormActive && currentSpaceWeatherData) {
                panel.style.display = 'block';
                
                // Determine most severe event
                let mostSevereEvent = null;
                let severityLevel = 'Low';
                let eventType = 'Solar Activity';
                
                if (currentSpaceWeatherData.flares.length > 0) {
                    mostSevereEvent = currentSpaceWeatherData.flares[0];
                    eventType = 'Solar Flare';
                    severityLevel = mostSevereEvent.classType?.includes('X') ? 'Extreme' : 'Moderate';
                } else if (currentSpaceWeatherData.seps.length > 0) {
                    mostSevereEvent = currentSpaceWeatherData.seps[0];
                    eventType = 'Solar Energetic Particle Event';
                    severityLevel = 'High';
                } else if (currentSpaceWeatherData.cmes.length > 0) {
                    mostSevereEvent = currentSpaceWeatherData.cmes[0];
                    eventType = 'Coronal Mass Ejection';
                    severityLevel = 'Moderate';
                }
                
                severity.textContent = severityLevel;
                stormType.textContent = eventType;
                
                if (mostSevereEvent) {
                    const eventTime = new Date(mostSevereEvent.beginTime || mostSevereEvent.peakTime || mostSevereEvent.eventTime || mostSevereEvent.activityID?.split('-')[0] + 'T00:00:00Z');
                    startTime.textContent = eventTime.toLocaleString();
                }
            } else {
                panel.style.display = 'none';
            }
        }
        let nextLevelId = 1; // Start next ID at 1
        let levelConfigs = [
            // Start with one default level
            { id: 0, shape: 'cylinder', radius: 4, length: 8, width: 8, height: 4, torusRadius: 8, tubeRadius: 2, volume: 0, group: null, parent: null },
        ];
        let designState = { 
            activeLevelId: 0, 
            snapGridSize: 0.5, 
            designMode: 'layout', 
            linkMode: false, 
            firstLinkLevel: null,
            currentView: '3d',
            removalMode: false,
        };

        // --- Initialization ---
        function init() {
            // Read mission parameters from localStorage passed from setup.html
            const savedCrewSize = localStorage.getItem('missionCrewSize');
            const savedMissionDuration = localStorage.getItem('missionDuration');

            if (savedCrewSize && savedMissionDuration) {
                missionParams.crewSize = parseInt(savedCrewSize, 10);
                missionParams.duration = parseInt(savedMissionDuration, 10);

                // Clean up localStorage so it doesn't persist on refresh
                localStorage.removeItem('missionCrewSize');
                localStorage.removeItem('missionDuration');
            }
            
            // Initialize Space Weather Monitoring
            checkSpaceWeather(); // Initial check
            spaceWeatherCheckInterval = setInterval(checkSpaceWeather, 15 * 60 * 1000); // Check every 15 minutes


            scene = new THREE.Scene();
            setupCameras();

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.localClippingEnabled = true;
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(15, 20, 10);
            scene.add(directionalLight);
            
            connectionsGroup = new THREE.Group();
            scene.add(connectionsGroup);

            setupControls();
            
            loadAssets();
            setupUI();
            createPlacementGrid();

            // Attempt to load from localStorage, otherwise create default shells
            const savedStateJSON = localStorage.getItem('habitatDesignerState');
            if (savedStateJSON) {
                try {
                    rebuildSceneFromState(JSON.parse(savedStateJSON));
                } catch (e) {
                    console.error("Failed to load saved state:", e);
                    localStorage.removeItem('habitatDesignerState');
                    createHabitatShells(); // Fallback to default
                }
            } else {
                 createHabitatShells(); // Default setup
            }

            runAnalysis();
            animate();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            canvasContainer.addEventListener('pointerdown', onCanvasClick);
            canvasContainer.addEventListener('dragover', onDragOver);
            canvasContainer.addEventListener('drop', onDrop);
        }
        
        function setupCameras() {
            const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            perspectiveCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            perspectiveCamera.position.copy(INITIAL_CAMERA_POS);
            
            const frustumSize = 30;
            orthographicCamera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            orthographicCamera.position.set(0, 50, 0);
            orthographicCamera.lookAt(scene.position);
            
            activeCamera = perspectiveCamera;
        }

        function setupControls() {
            orbitControls = new OrbitControls(activeCamera, renderer.domElement);
            orbitControls.enableDamping = true;

            transformControls = new TransformControls(activeCamera, renderer.domElement);
            scene.add(transformControls);
            transformControls.addEventListener('dragging-changed', event => { 
                orbitControls.enabled = !event.value; 
                if (!event.value && transformControls.object) {
                    if (designState.designMode === 'layout') {
                        snapToGrid(transformControls.object);
                    }
                }
            });
            transformControls.addEventListener('objectChange', () => {
                const selectedObject = transformControls.object;
                if (!selectedObject) return;

                if (selectedObject.userData.isModule) {
                    constrainModulePosition(selectedObject);
                    const box = new THREE.Box3().setFromObject(selectedObject);
                    const size = box.getSize(new THREE.Vector3());
                    selectedObject.userData.volume = size.x * size.y * size.z;
                }
                updateConnectionsVisuals();
                runAnalysis();
            });
        }

        function loadAssets() {
            const loadingManager = new THREE.LoadingManager(() => {
                document.getElementById('loading-overlay').style.display = 'none';
                document.getElementById('app-container').style.opacity = 1;
            });
            const cubeTextureLoader = new THREE.CubeTextureLoader(loadingManager);
            const textureLoader = new THREE.TextureLoader(loadingManager);

            const skyboxTexture = cubeTextureLoader.load([
                'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_px.jpg', 'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_nx.jpg',
                'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_py.jpg', 'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_ny.jpg',
                'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_pz.jpg', 'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_nz.jpg'
            ]);
            scene.userData.skyboxTexture = skyboxTexture;
            
            const groundTexture = textureLoader.load('https://threejs.org/examples/textures/planets/mars_1k_color.jpg', (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(100, 100);
            });
            const groundMat = new THREE.MeshStandardMaterial({ map: groundTexture, side: THREE.DoubleSide });
            const groundGeo = new THREE.PlaneGeometry(500, 500);
            groundPlane = new THREE.Mesh(groundGeo, groundMat);
            groundPlane.rotation.x = -Math.PI / 2;

            createSurfaceFeatures();
            updateSceneEnvironment();
        }
        
        function createPlacementGrid() {
            placementGrid = new THREE.GridHelper(100, 200, 0x4f46e5, 0x444444);
            placementGrid.visible = false;
            scene.add(placementGrid);
        }

        function createSurfaceFeatures() {
            surfaceFeatures = new THREE.Group();
            const rockGeometry = new THREE.IcosahedronGeometry(1, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.8 });

            for (let i = 0; i < 200; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    (Math.random() - 0.5) * 400,
                    (Math.random() * 0.2),
                    (Math.random() - 0.5) * 400
                );
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                const scale = Math.random() * 0.5 + 0.1;
                rock.scale.set(scale, scale * (Math.random() * 0.5 + 0.8), scale);
                surfaceFeatures.add(rock);
            }
        }
        
        // --- Event Handlers & User Interaction ---
        function onWindowResize() {
            const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();

            const frustumSize = 30;
            orthographicCamera.left = frustumSize * aspect / -2;
            orthographicCamera.right = frustumSize * aspect / 2;
            orthographicCamera.top = frustumSize / 2;
            orthographicCamera.bottom = frustumSize / -2;
            orthographicCamera.updateProjectionMatrix();

            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }

        function onKeyDown(event) {
            switch(event.key.toLowerCase()) {
                case 'w': transformControls.setMode('translate'); break;
                case 'e': transformControls.setMode('rotate'); break;
                case 's': transformControls.setMode('scale'); break;
                case 'q':
                case 'delete':
                    deleteSelectedObject();
                    break;
                case 'escape': 
                    deselectObject();
                    if (designState.linkMode) toggleLinkMode();
                    if (designState.removalMode) toggleRemovalMode();
                    break;
            }
        }
        
        function onCanvasClick(event) {
            if (transformControls.dragging) return;
            
            pointer.x = (event.offsetX / renderer.domElement.clientWidth) * 2 - 1;
            pointer.y = - (event.offsetY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, activeCamera);

            if (designState.designMode === 'layout') {
                const moduleMeshes = internalModules.filter(m => m.visible);
                const intersectsModules = raycaster.intersectObjects(moduleMeshes);
                if (intersectsModules.length > 0) {
                    selectObject(intersectsModules[0].object);
                    return;
                }
            }
            
            const habitatShellMeshes = levelConfigs.map(c => c.group?.userData.shellMesh).filter(m => m);
            if(habitatShellMeshes.length === 0) return;

            const intersects = raycaster.intersectObjects(habitatShellMeshes);
            if (intersects.length > 0) {
                const shellGroup = intersects[0].object.parent;
                if (shellGroup && shellGroup.userData.levelId !== undefined) {
                    const levelId = shellGroup.userData.levelId;
                    if (designState.designMode === 'build') {
                        if (designState.linkMode) {
                            handleLinkClick(levelId);
                        } else {
                            let rootParent = shellGroup;
                            let rootConfig = levelConfigs.find(c => c.id === levelId);
                            while (rootConfig && rootConfig.parent !== null) {
                                rootConfig = levelConfigs.find(c => c.id === rootConfig.parent);
                                rootParent = rootConfig.group;
                            }
                            selectObject(rootParent);
                        }
                    }
                }
            } else {
                 if (!transformControls.dragging) {
                     deselectObject();
                 }
            }
        }
        
        function onDragOver(event) {
            event.preventDefault();
        }

        function onDrop(event) {
            event.preventDefault();
            if (designState.designMode !== 'layout') return;

            const activeLevelConfig = levelConfigs.find(c => c.id === designState.activeLevelId);
            if (activeLevelConfig.shape === 'truss') {
                 updateAlertsUI(new Set(['Modules cannot be placed inside a Truss structure.']));
                 setTimeout(() => runAnalysis(), 3000);
                 return;
            }

            const moduleName = event.dataTransfer.getData("text/plain");
            const config = MODULE_TYPES[moduleName];
            if (!config) return;

            pointer.x = (event.offsetX / renderer.domElement.clientWidth) * 2 - 1;
            pointer.y = - (event.offsetY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, activeCamera);

            const activeLevelGroup = activeLevelConfig?.group;
            if (!activeLevelGroup) return;

            const localPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), activeLevelGroup.userData.height / 2);
            const worldPlane = localPlane.clone().applyMatrix4(activeLevelGroup.matrixWorld);
            
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(worldPlane, intersectPoint);
            
            if (intersectPoint) {
                addFunctionalModule(moduleName, config, intersectPoint);
            }
            canvasContainer.addEventListener('drop', onDrop);
        }
        
        function setupUI() {
            document.getElementById('back-btn').addEventListener('click', () => { window.location.href = '../forms/briefing.html'; });
            
            // POPUP EVENT LISTENERS
            document.getElementById('summary-btn').addEventListener('click', openSummaryPopup);
            document.getElementById('closeSummaryPopupBtn').addEventListener('click', closeSummaryPopup);
            summaryPopupOverlay.addEventListener('click', function(event) {
                if (event.target === summaryPopupOverlay) {
                    closeSummaryPopup();
                }
            });

            document.querySelectorAll('input[name="environment"]').forEach(radio => radio.addEventListener('change', (e) => { missionParams.environment = e.target.value; updateHabitatShapeOptions(); updateSceneEnvironment(); createHabitatShells(); }));
            document.querySelectorAll('input[name="design-mode"]').forEach(radio => radio.addEventListener('change', (e) => { 
                designState.designMode = e.target.value; 
                deselectObject(); 
                if (designState.designMode === 'build') {
                    buildModeHelp.classList.remove('hidden');
                } else {
                    buildModeHelp.classList.add('hidden');
                }
                updateLevelView();
                if (designState.linkMode) toggleLinkMode();
            }));
            
            const modulePalette = document.getElementById('module-palette');
            modulePalette.innerHTML = '';
            Object.keys(MODULE_TYPES).forEach(name => {
                const config = MODULE_TYPES[name];
                const button = document.createElement('div');
                const iconSVG = MODULE_ICONS[name] || MODULE_ICONS['default'];
                const hexColor = `#${new THREE.Color(config.color).getHexString()}`;

                button.draggable = true;
                button.dataset.moduleName = name;
                button.title = `${name} - Vol/Crew: ${config.volumePerCrew} m³`;
                button.className = 'module-button flex flex-col items-center justify-center p-2 bg-gray-700 rounded-lg text-xs font-medium text-gray-200 transition-all duration-200 transform hover:scale-105 hover:shadow-lg border-2 border-transparent cursor-grab';
                
                button.style.setProperty('--module-color', hexColor);
                button.onmouseenter = () => button.style.borderColor = button.style.getPropertyValue('--module-color');
                button.onmouseleave = () => button.style.borderColor = 'transparent';

                button.innerHTML = `
                    ${iconSVG}
                    <span>${name}</span>
                `;

                button.addEventListener('dragstart', (event) => {
                    event.dataTransfer.setData("text/plain", event.currentTarget.dataset.moduleName);
                    event.dataTransfer.effectAllowed = "copy";
                });

                button.addEventListener('click', (event) => {
                    if (designState.designMode !== 'layout') return;
                    const moduleName = event.currentTarget.dataset.moduleName;
                    const config = MODULE_TYPES[moduleName];
                    if (!config) return;

                    const activeLevelGroup = levelConfigs.find(c => c.id === designState.activeLevelId)?.group;
                    if (!activeLevelGroup) return;

                    if (activeLevelGroup.userData.shape === 'truss') {
                         updateAlertsUI(new Set(['Modules cannot be placed inside a Truss structure.']));
                         setTimeout(() => runAnalysis(), 3000);
                         return;
                    }
                    
                    const centerPosition = new THREE.Vector3();
                    activeLevelGroup.getWorldPosition(centerPosition);

                    addFunctionalModule(moduleName, config, centerPosition);
                });
                
                modulePalette.appendChild(button);
            });

            const viewModeBtn = document.getElementById('view-mode-btn');
            const viewOptions = document.getElementById('view-options');
            viewModeBtn.addEventListener('click', () => {
                viewOptions.classList.toggle('hidden');
            });
            document.body.addEventListener('click', (e) => {
                if (!viewModeBtn.contains(e.target)) {
                    viewOptions.classList.add('hidden');
                }
            });

            document.querySelectorAll('#view-options a').forEach(option => {
                option.addEventListener('click', (e) => {
                    e.preventDefault();
                    const viewMode = e.currentTarget.dataset.view;
                    setViewMode(viewMode);
                    viewOptions.classList.add('hidden');
                });
            });

            resetCameraBtn.addEventListener('click', resetCamera);
            habitatShapeSelect.addEventListener('change', e => { levelConfigs.find(c => c.id === designState.activeLevelId).shape = e.target.value; createHabitatShells(); updateLevelSelectorVisuals(); });
            document.getElementById('link-mode-btn').addEventListener('click', toggleLinkMode);
            document.getElementById('unlink-all-btn').addEventListener('click', unlinkAllLevels);
            document.getElementById('clear-modules-btn').addEventListener('click', clearAllModules);
            document.getElementById('add-level-btn').addEventListener('click', addLevel);
            document.getElementById('remove-level-btn').addEventListener('click', toggleRemovalMode);
            document.getElementById('stack-levels-btn').addEventListener('click', stackAllLevels);
            document.getElementById('delete-module-btn').addEventListener('click', deleteSelectedObject);

            // Save/Load Listeners
            document.getElementById('save-btn').addEventListener('click', saveState);
            document.getElementById('download-btn').addEventListener('click', downloadState);
            const loadInput = document.getElementById('load-input');
            document.getElementById('load-btn').addEventListener('click', () => loadInput.click());
            loadInput.addEventListener('change', loadStateFromFile);
            
            updateHabitatShapeOptions();
            populateChecklist();
            populateLevelSelectors();
            updateHabitatShellControls();
        }
        
        // --- Core Application Logic ---
        function addLevel() {
            if (levelConfigs.length >= 10) {
                updateAlertsUI(new Set(["Maximum number of levels (10) reached."]));
                setTimeout(() => runAnalysis(), 3000);
                return;
            }
            const newId = nextLevelId++;
            levelConfigs.push({
                id: newId, shape: 'cylinder', radius: 4, length: 8, width: 8, height: 4, torusRadius: 8, tubeRadius: 2, volume: 0, group: null, parent: null
            });

            createHabitatShells(); 
            designState.activeLevelId = newId;
            populateLevelSelectors(); 
            updateLevelView();
            updateHabitatShellControls();
            document.querySelector(`.level-btn[data-level-id="${newId}"]`).classList.add('active');
        }

        function removeSpecificLevel(levelIdToRemove) {
            if (levelConfigs.length <= 1) {
                updateAlertsUI(new Set(["Cannot remove the last level."]));
                setTimeout(() => runAnalysis(), 3000);
                return;
            }
            const configToRemove = levelConfigs.find(c => c.id === levelIdToRemove);
            if (!configToRemove) return;

            levelConfigs.forEach(config => {
                if (config.parent === levelIdToRemove) {
                    scene.attach(config.group);
                    config.parent = null;
                }
            });

            [...internalModules].forEach(m => {
                if(m.userData.level === levelIdToRemove) {
                    const index = internalModules.indexOf(m);
                    if (index > -1) internalModules.splice(index, 1);
                }
            });
            
            if (configToRemove.group) {
                if (transformControls.object === configToRemove.group) deselectObject();
                while(configToRemove.group.children.length > 0) configToRemove.group.remove(configToRemove.group.children[0]);
                scene.remove(configToRemove.group);
            }

            const configIndex = levelConfigs.findIndex(c => c.id === levelIdToRemove);
            if (configIndex > -1) levelConfigs.splice(configIndex, 1);
            
            if(designState.activeLevelId === levelIdToRemove) {
                designState.activeLevelId = levelConfigs.length > 0 ? levelConfigs[0].id : null;
            }

            populateLevelSelectors();
            updateLevelView();
            updateConnectionsVisuals();
            runAnalysis();
        }
        
        function stackAllLevels() {
            deselectObject();
            unlinkAllLevels(); 
            let currentY = 0;
            const rootLevels = levelConfigs.filter(c => c.parent === null);

            rootLevels.forEach(config => {
                if (config.group) {
                    const shellHeight = config.group.userData.height;
                    const yPosition = missionParams.environment === 'surface' ? shellHeight / 2 : currentY + shellHeight / 2;
                    config.group.position.set(0, yPosition, 0);
                    config.group.rotation.set(0, 0, 0);
                    currentY += shellHeight;
                }
            });
        }
        
        function addFunctionalModule(name, config, position, rotation, scale) {
            const activeGroup = levelConfigs.find(c => c.id === designState.activeLevelId)?.group;
            if (!activeGroup) return;

            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const defaultMaterial = new THREE.MeshStandardMaterial({ color: config.color, clippingPlanes: clippingPlanes });
            const realisticMaterial = new THREE.MeshStandardMaterial({ color: config.color, metalness: 0.5, roughness: 0.5 });
            const module = new THREE.Mesh(geometry, defaultMaterial);
            
            const localPosition = activeGroup.worldToLocal(position.clone());
            module.position.copy(localPosition);
            
            module.position.y = (-activeGroup.userData.height / 2) + 1; 

            if (rotation) module.quaternion.copy(rotation);
            if (scale) module.scale.copy(scale);
            
            module.userData = { name, config, volume: 8, requiredVolume: 0, status: 'valid', level: designState.activeLevelId, isModule: true, defaultMaterial, realisticMaterial };
            
            activeGroup.add(module);
            internalModules.push(module);
            snapToGrid(module);
            selectObject(module);
            runAnalysis();
        }

        function createHabitatShells(isInitialLoad = false) {
            levelConfigs.forEach(config => {
                if (config.parent !== null && config.group) {
                    scene.attach(config.group);
                }
            });

            let initialXOffset = -((levelConfigs.length - 1) * 10);

            levelConfigs.forEach((config) => {
                 const oldPosition = config.group ? config.group.position.clone() : null;
                 const oldRotation = config.group ? config.group.rotation.clone() : null;
                 const oldScale = config.group ? config.group.scale.clone() : null;

                 if (config.group) {
                    // Clear previous geometry and materials before adding new ones
                    const objectsToRemove = [...config.group.children];
                    objectsToRemove.forEach(child => {
                        if(child.userData.isModule) return; // Don't remove modules, only shell parts
                        config.group.remove(child);
                    });
                 } else {
                      config.group = new THREE.Group();
                      scene.add(config.group);
                 }
                 config.group.userData.levelId = config.id;

                let geometry, volume = 0, levelHeight = 0;
                const { shape, radius, length, width, height, torusRadius, tubeRadius } = config;
                 config.group.userData.shape = shape;
                switch (shape) {
                    case 'cylinder': geometry = new THREE.CylinderGeometry(radius, radius, length, 64); volume = Math.PI * radius * radius * length; levelHeight = length; break;
                    case 'inflatable': geometry = new THREE.CapsuleGeometry(radius, length - (radius * 2), 32, 64); volume = (Math.PI * radius * radius * (length - (radius*2))) + ((4/3) * Math.PI * Math.pow(radius, 3)); levelHeight = length; break;
                    case 'dome': geometry = new THREE.SphereGeometry(radius, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2); volume = (2/3) * Math.PI * Math.pow(radius, 3); levelHeight = radius; break;
                    case 'torus': geometry = new THREE.TorusGeometry(torusRadius, tubeRadius, 32, 100); volume = (Math.PI * tubeRadius * tubeRadius) * (2 * Math.PI * torusRadius); levelHeight = tubeRadius * 2; break;
                    case 'connector': geometry = new THREE.BoxGeometry(width, height, length); volume = width * height * length; levelHeight = height; break;
                    case 'hexagon': 
                        geometry = new THREE.CylinderGeometry(radius, radius, length, 6); 
                        volume = (3 * Math.sqrt(3) / 2) * radius * radius * length; 
                        levelHeight = length; 
                        break;
                    case 'spindle': 
                        geometry = new THREE.SphereGeometry(radius, 32, 16);
                        geometry.applyMatrix4(new THREE.Matrix4().makeScale(1.0, 1.0, length / (radius * 2)));
                        volume = (4/3) * Math.PI * radius * radius * (length / 2);
                        levelHeight = radius * 2;
                        break;
                    case 'saucer': 
                        geometry = new THREE.CylinderGeometry(radius, radius * 0.8, height, 64);
                        volume = Math.PI * height / 3 * (radius*radius + (radius*0.8)*(radius*0.8) + radius*(radius*0.8)); // Frustum volume
                        levelHeight = height;
                        break;
                    case 'truss':
                        geometry = new THREE.BoxGeometry(width, height, length);
                        volume = 0;
                        levelHeight = height;
                        break;
                    default: geometry = new THREE.BoxGeometry(1,1,1); levelHeight = 1;
                }
                config.volume = volume;
                config.group.userData.height = levelHeight;

                const defaultMaterial = new THREE.MeshStandardMaterial({ color: ACTIVE_SHELL_COLOR, transparent: true, opacity: 0.1, side: THREE.DoubleSide, clippingPlanes: clippingPlanes, clipShadows: true });
                const realisticMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.2, side: THREE.DoubleSide });
                const shellMesh = new THREE.Mesh(geometry, defaultMaterial);
                shellMesh.userData.defaultMaterial = defaultMaterial;
                shellMesh.userData.realisticMaterial = realisticMaterial;
                
                config.group.add(shellMesh);
                config.group.userData.shellMesh = shellMesh;
                
                const wireframeGeo = new THREE.WireframeGeometry(geometry);
                const wireframeMat = new THREE.LineBasicMaterial({ color: 0x6366f1, transparent: true, opacity: 0.2, clippingPlanes: clippingPlanes });
                const wireframe = new THREE.LineSegments(wireframeGeo, wireframeMat);
                config.group.add(wireframe);
                config.group.userData.wireframeMesh = wireframe;
                
                 if (shape === 'truss') {
                    const trussMaterial = new THREE.MeshStandardMaterial({ color: 0x9ca3af, metalness: 0.8, roughness: 0.4 });
                    const strutGeo = new THREE.CylinderGeometry(0.2, 0.2, height, 8);
                    for(let i = -length/2; i <= length/2; i += 4) {
                        const strut1 = new THREE.Mesh(strutGeo, trussMaterial);
                        strut1.position.set(width/2, 0, i);
                        config.group.add(strut1);
                        const strut2 = new THREE.Mesh(strutGeo, trussMaterial);
                        strut2.position.set(-width/2, 0, i);
                        config.group.add(strut2);
                    }
                 }
                
                 if (!oldPosition && !isInitialLoad) {
                      config.group.position.set(initialXOffset, levelHeight / 2, 0);
                      initialXOffset += 20;
                 } else if (oldPosition) {
                      config.group.position.copy(oldPosition);
                      config.group.rotation.copy(oldRotation);
                      config.group.scale.copy(oldScale);
                 }
            });
            
            reparentLevels();
            setViewMode(designState.currentView);
            updateDimensionControls();
            updateLevelView();
            runAnalysis();
        }

        function constrainModuleY(object) {
            if (!object || !object.parent || !object.userData.isModule) return;
            const parentHeight = object.parent.userData.height || 0;
            const moduleHeight = (object.geometry.parameters.height || 2) * object.scale.y;
            const floorY = -parentHeight / 2;
            const ceilingY = parentHeight / 2;
            const minY = floorY + moduleHeight / 2;
            const maxY = ceilingY - moduleHeight / 2;
            object.position.y = Math.max(minY, Math.min(object.position.y, maxY));
        }

        function constrainModuleXZ(object) {
            if (!object || !object.parent || !object.userData.isModule) return;
            const levelId = object.userData.level;
            const levelConfig = levelConfigs.find(c => c.id === levelId);
            if (!levelConfig) return;

            const moduleBox = new THREE.Box3().setFromObject(object);
            const moduleSize = moduleBox.getSize(new THREE.Vector3());
            const moduleRadius = Math.sqrt((moduleSize.x / 2)**2 + (moduleSize.z / 2)**2);
            const shape = levelConfig.shape;

            if (shape === 'cylinder' || shape === 'inflatable' || shape === 'dome' || shape === 'saucer' || shape === 'spindle') {
                const habitatRadius = levelConfig.radius;
                const maxDistance = habitatRadius - moduleRadius;
                const distanceFromCenter = Math.sqrt(object.position.x**2 + object.position.z**2);
                if (distanceFromCenter > maxDistance && distanceFromCenter > 0) {
                    const ratio = maxDistance / distanceFromCenter;
                    object.position.x *= ratio;
                    object.position.z *= ratio;
                }
            } else if (shape === 'hexagon') {
                const habitatRadius = levelConfig.radius * (Math.sqrt(3) / 2);
                const maxDistance = habitatRadius - moduleRadius;
                const distanceFromCenter = Math.sqrt(object.position.x**2 + object.position.z**2);
                if (distanceFromCenter > maxDistance && distanceFromCenter > 0) {
                    const ratio = maxDistance / distanceFromCenter;
                    object.position.x *= ratio;
                    object.position.z *= ratio;
                }
            } else if (shape === 'connector' || shape === 'truss') {
                const halfWidth = (levelConfig.width / 2) - (moduleSize.x / 2);
                const halfLength = (levelConfig.length / 2) - (moduleSize.z / 2);
                object.position.x = Math.max(-halfWidth, Math.min(object.position.x, halfWidth));
                object.position.z = Math.max(-halfLength, Math.min(object.position.z, halfLength));
            } else if (shape === 'torus') {
                const tubeRadius = levelConfig.tubeRadius;
                const torusRadius = levelConfig.torusRadius;
                const modulePosXZ = new THREE.Vector2(object.position.x, object.position.z);
                if (modulePosXZ.lengthSq() === 0) return;
                const directionToModule = modulePosXZ.clone().normalize();
                const ringCenter = directionToModule.clone().multiplyScalar(torusRadius);
                const modulePos3D = object.position.clone();
                const ringCenter3D = new THREE.Vector3(ringCenter.x, 0, ringCenter.y);
                const vectorFromRingCenter = modulePos3D.sub(ringCenter3D);
                const distanceToRingCenter = vectorFromRingCenter.length();
                const maxTubeDistance = tubeRadius - moduleRadius;
                if (distanceToRingCenter > maxTubeDistance) {
                    vectorFromRingCenter.normalize().multiplyScalar(maxTubeDistance);
                    const newPos = ringCenter3D.add(vectorFromRingCenter);
                    object.position.copy(newPos);
                }
            }
        }

        function constrainModulePosition(object) {
            constrainModuleY(object);
            constrainModuleXZ(object);
        }

        function snapToGrid(object) {
            if (!object || !object.parent) return;
            const gridSize = designState.snapGridSize;
            object.position.x = Math.round(object.position.x / gridSize) * gridSize;
            object.position.z = Math.round(object.position.z / gridSize) * gridSize;
            constrainModulePosition(object);
            runAnalysis();
        }

        function updateLevelView() {
            const isRealistic = designState.currentView === 'realistic';
            const activeLevelConfig = levelConfigs.find(c => c.id === designState.activeLevelId);

            // Handle clipping planes and grid visibility globally
            if (isRealistic || designState.designMode === 'build') {
                clippingPlanes[0].constant = 1000;
                placementGrid.visible = false;
            } else { // Layout mode, not realistic
                const activeGroup = activeLevelConfig?.group;
                if (activeGroup) {
                    const box = new THREE.Box3().setFromObject(activeGroup);
                    clippingPlanes[0].constant = box.max.y;
                    const floorY = activeGroup.position.y - (activeGroup.userData.height / 2);
                    placementGrid.position.y = floorY + 0.01;
                    placementGrid.visible = designState.currentView !== '2d';
                } else {
                    placementGrid.visible = false;
                }
            }

            // Handle visibility and colors per level
            levelConfigs.forEach((config) => {
                const group = config.group;
                if (!group) return;
                
                const isActiveLayout = (config.id === designState.activeLevelId) && (designState.designMode === 'layout');

                if (!isRealistic) {
                    const shellMesh = group.userData.shellMesh;
                    shellMesh.material.color.setHex(isActiveLayout ? ACTIVE_SHELL_COLOR : COMPLETED_SHELL_COLOR);
                    shellMesh.material.opacity = isActiveLayout ? 0.15 : 0.1;
                }

                group.children.forEach(child => {
                    if (child.userData.isModule) {
                        child.visible = isRealistic || isActiveLayout;
                        if (transformControls.object === child && !child.visible) {
                            deselectObject();
                        }
                    }
                });
            });
        }
        
        // --- View Management ---
        function setViewMode(mode) {
            designState.currentView = mode;
            const viewModeBtnSpan = document.querySelector('#view-mode-btn span');
            
            deselectObject();
            orbitControls.enableRotate = true;

            const isRealistic = mode === 'realistic';

            // Apply materials and visibility
            levelConfigs.forEach(config => {
                if (config.group && config.group.userData.shellMesh) {
                    const shellMesh = config.group.userData.shellMesh;
                    shellMesh.material = isRealistic ? shellMesh.userData.realisticMaterial : shellMesh.userData.defaultMaterial;
                    if (config.group.userData.wireframeMesh) {
                        config.group.userData.wireframeMesh.visible = !isRealistic;
                    }
                }
            });
            internalModules.forEach(module => {
                module.material = isRealistic ? module.userData.realisticMaterial : module.userData.defaultMaterial;
            });


            if (mode === '2d') {
                activeCamera = orthographicCamera;
                viewModeBtnSpan.textContent = '2D View';
                orbitControls.enableRotate = false;
            } else { // 3d or realistic
                activeCamera = perspectiveCamera;
                if (mode === '3d') {
                    viewModeBtnSpan.textContent = '3D View';
                } else if (mode === 'realistic') {
                    viewModeBtnSpan.textContent = 'Realistic View';
                }
            }
            
            updateLevelView();

            orbitControls.object = activeCamera;
            transformControls.camera = activeCamera;
            orbitControls.reset();
            onWindowResize();
        }


        function resetCamera() {
            setViewMode('3d');
            orbitControls.reset();
            perspectiveCamera.position.copy(INITIAL_CAMERA_POS);
        }

        function animate() { 
            requestAnimationFrame(animate); 
            orbitControls.update();
            renderer.render(scene, activeCamera);
        }

        // --- Save & Load ---
        function saveState() {
            const state = {
                missionParams,
                nextLevelId,
                levelConfigs: levelConfigs.map(c => ({
                    ...c,
                    group: null, // Don't save the THREE.Group object itself
                    transform: c.group ? {
                        position: c.group.position.toArray(),
                        quaternion: c.group.quaternion.toArray(),
                        scale: c.group.scale.toArray()
                    } : null
                })),
                internalModules: internalModules.map(m => ({
                    name: m.userData.name,
                    level: m.userData.level,
                    transform: {
                        position: m.position.toArray(),
                        quaternion: m.quaternion.toArray(),
                        scale: m.scale.toArray()
                    }
                }))
            };
            const jsonState = JSON.stringify(state, null, 2);
            localStorage.setItem('habitatDesignerState', jsonState);
            console.log("State saved to localStorage.");
            return jsonState;
        }

        function downloadState() {
            const jsonState = saveState();
            const blob = new Blob([jsonState], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'habitat-design.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadStateFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const state = JSON.parse(e.target.result);
                    rebuildSceneFromState(state);
                } catch (err) {
                    console.error("Error parsing loaded file:", err);
                    alert("Error: Could not load the design file. It may be corrupted.");
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input to allow loading the same file again
        }

        function rebuildSceneFromState(state) {
            // 1. Clear current scene
            deselectObject();
            levelConfigs.forEach(c => c.group && scene.remove(c.group));
            internalModules.length = 0;
            
            // 2. Load state data
            missionParams = state.missionParams;
            levelConfigs = state.levelConfigs.map(c => ({ ...c, group: null })); // groups will be created
            nextLevelId = state.nextLevelId || Math.max(...levelConfigs.map(c=>c.id)) + 1;
            
            // 3. Rebuild scene objects
            createHabitatShells(true); // Create shells without default positioning

            // 4. Apply transforms to levels
            state.levelConfigs.forEach(savedConfig => {
                const config = levelConfigs.find(c => c.id === savedConfig.id);
                if (config && config.group && savedConfig.transform) {
                    config.group.position.fromArray(savedConfig.transform.position);
                    config.group.quaternion.fromArray(savedConfig.transform.quaternion);
                    config.group.scale.fromArray(savedConfig.transform.scale);
                }
            });
            reparentLevels();

            // 5. Re-add modules
            state.internalModules.forEach(savedModule => {
                const moduleConfig = MODULE_TYPES[savedModule.name];
                if (!moduleConfig) return;

                const parentLevel = levelConfigs.find(c => c.id === savedModule.level);
                if (!parentLevel || !parentLevel.group) return;

                designState.activeLevelId = savedModule.level; // Temporarily set active level to add module
                
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const defaultMaterial = new THREE.MeshStandardMaterial({ color: moduleConfig.color, clippingPlanes: clippingPlanes });
                const realisticMaterial = new THREE.MeshStandardMaterial({ color: moduleConfig.color, metalness: 0.5, roughness: 0.5 });
                const module = new THREE.Mesh(geometry, defaultMaterial);
                
                module.position.fromArray(savedModule.transform.position);
                module.quaternion.fromArray(savedModule.transform.quaternion);
                module.scale.fromArray(savedModule.transform.scale);
                
                module.userData = { name: savedModule.name, config: moduleConfig, volume: 8, requiredVolume: 0, status: 'valid', level: savedModule.level, isModule: true, defaultMaterial, realisticMaterial };
            
                parentLevel.group.add(module);
                internalModules.push(module);
            });


            // 6. Refresh UI and analysis
            if (levelConfigs.length > 0) {
                 designState.activeLevelId = levelConfigs[0].id;
            }
            updateUIFromMissionParams();
            populateLevelSelectors();
            updateHabitatShellControls();
            setViewMode('3d'); // Always load in default 3d view
            runAnalysis();
        }


        // --- UI & State Functions ---
        function reparentLevels() { levelConfigs.forEach(config => { if (config.parent !== null) { const parentConfig = levelConfigs.find(p => p.id === config.parent); if (parentConfig && parentConfig.group) { parentConfig.group.attach(config.group); } } }); updateConnectionsVisuals(); }
        
        function populateLevelSelectors() { 
            const levelSelector = document.getElementById('level-selector'); 
            levelSelector.innerHTML = ''; 
            levelConfigs.forEach((config) => { 
                const button = document.createElement('button'); 
                button.dataset.levelId = config.id; 
                button.className = 'level-btn flex flex-col items-center justify-center p-2 text-xs bg-gray-700 rounded-lg border-2 border-gray-600 hover:bg-gray-600 transition-colors'; 
                button.innerHTML = `<div class="shape-icon w-8 h-8 mb-1"></div><span>Level ${config.id + 1}</span>`; 
                button.addEventListener('click', () => { 
                    const levelId = parseInt(button.dataset.levelId);
                    if (designState.removalMode) {
                        removeSpecificLevel(levelId);
                        toggleRemovalMode(); 
                    } else {
                        designState.activeLevelId = levelId; 
                        document.querySelectorAll('.level-btn').forEach(btn => btn.classList.remove('active')); 
                        button.classList.add('active'); 
                        updateHabitatShellControls(); 
                        updateLevelView(); 
                    }
                }); 
                levelSelector.appendChild(button); 
            }); 
            const activeButton = document.querySelector(`.level-btn[data-level-id="${designState.activeLevelId}"]`); 
            if(activeButton) activeButton.classList.add('active'); 
            updateLevelSelectorVisuals(); 
        }

        function updateLevelSelectorVisuals() { 
            const getShapeSVG = (shape) => { 
                const stroke = 'currentColor'; 
                switch (shape) { 
                    case 'cylinder': case 'inflatable': return `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><ellipse cx="20" cy="8" rx="15" ry="5" stroke="${stroke}" fill="none" stroke-width="2"/><line x1="5" y1="8" x2="5" y2="32" stroke="${stroke}" stroke-width="2"/><line x1="35" y1="8" x2="35" y2="32" stroke="${stroke}" stroke-width="2"/><ellipse cx="20" cy="32" rx="15" ry="5" stroke="${stroke}" fill="none" stroke-width="2"/></svg>`; 
                    case 'dome': return `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M 5 35 A 1 1 0 0 1 35 35 Z" stroke="${stroke}" fill="none" stroke-width="2"/><line x1="5" y1="35" x2="35" y2="35" stroke="${stroke}" stroke-width="2"/></svg>`; 
                    case 'torus': return `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><circle cx="20" cy="20" r="15" stroke="${stroke}" fill="none" stroke-width="2"/><circle cx="20" cy="20" r="8" stroke="${stroke}" fill="none" stroke-width="2"/></svg>`; 
                    case 'connector': return `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="5" y="10" width="30" height="20" stroke="${stroke}" fill="none" stroke-width="2"/></svg>`;
                    case 'hexagon': return `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M20 5 L35 12.5 L35 27.5 L20 35 L5 27.5 L5 12.5 Z" stroke="${stroke}" fill="none" stroke-width="2"/></svg>`;
                    case 'spindle': return `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><ellipse cx="20" cy="20" rx="18" ry="8" stroke="${stroke}" fill="none" stroke-width="2"/></svg>`;
                    case 'saucer': return `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><ellipse cx="20" cy="20" rx="18" ry="6" stroke="${stroke}" fill="none" stroke-width="2"/><path d="M 2 20 L 38 20" stroke="${stroke}" fill="none" stroke-width="1.5" stroke-dasharray="2,2"/></svg>`;
                    case 'truss': return `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="15" width="36" height="10" stroke="${stroke}" fill="none" stroke-width="2"/><line x1="2" y1="15" x2="38" y2="25" stroke="${stroke}" stroke-width="1"/><line x1="2" y1="25" x2="38" y2="15" stroke="${stroke}" stroke-width="1"/></svg>`;
                    default: return ''; 
                } 
            }; 
            document.querySelectorAll('.level-btn').forEach(btn => { const levelId = parseInt(btn.dataset.levelId); const config = levelConfigs.find(c => c.id === levelId); if(config) { btn.querySelector('.shape-icon').innerHTML = getShapeSVG(config.shape); } }); 
        }
        function populateChecklist() { checklistListEl.innerHTML = ''; ESSENTIAL_MODULES.forEach(name => { const li = document.createElement('li'); li.id = `checklist-${name.replace(/\s+/g, '-')}`; li.innerHTML = `<span class="mr-2">&#10008;</span> ${name}`; li.className = 'text-red-400'; checklistListEl.appendChild(li); }); }
        function updateHabitatShapeOptions() { const currentShapes = HABITAT_SHAPES[missionParams.environment]; habitatShapeSelect.innerHTML = ''; let shapeNames = {}; Object.entries(currentShapes).forEach(([displayName, value]) => { const option = document.createElement('option'); option.value = value; option.textContent = displayName; habitatShapeSelect.appendChild(option); shapeNames[value] = displayName; }); scene.userData.shapeNames = shapeNames; }
        function updateHabitatShellControls() { const activeConfig = levelConfigs.find(c => c.id === designState.activeLevelId); if(!activeConfig) return; habitatShapeSelect.value = activeConfig.shape; updateDimensionControls(); }
        function updateDimensionControls() { 
            const container = document.getElementById('dimension-controls'); 
            container.innerHTML = ''; 
            const activeConfig = levelConfigs.find(c => c.id === designState.activeLevelId); 
            if(!activeConfig) return; 
            const createSlider = (id, label, min, max, value, step) => { const wrapper = document.createElement('div'); const flex = document.createElement('div'); flex.className = 'flex items-center justify-between'; flex.innerHTML = `<label for="${id}" class="text-sm">${label}:</label><span id="${id}-value" class="font-mono text-indigo-400">${value}</span>`; const slider = document.createElement('input'); slider.type = 'range'; slider.id = id; slider.min = min; slider.max = max; slider.value = value; slider.step = step; slider.className = 'w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider-thumb mt-1'; wrapper.appendChild(flex); wrapper.appendChild(slider); return { wrapper, slider }; }; 
            const shape = activeConfig.shape; 
            if (['cylinder', 'inflatable', 'dome', 'hexagon', 'saucer', 'spindle'].includes(shape)) {
                const r = createSlider('radius', 'Radius (m)', 2, 10, activeConfig.radius, 0.1);
                container.appendChild(r.wrapper);
                r.slider.addEventListener('input', e => { activeConfig.radius = parseFloat(e.target.value); document.getElementById('radius-value').textContent = activeConfig.radius.toFixed(1); createHabitatShells(); });
            }
            if (['cylinder', 'inflatable', 'hexagon', 'spindle'].includes(shape)) {
                const l = createSlider('length', 'Length (m)', 2, (shape === 'spindle' ? 30 : 20), activeConfig.length, 0.1);
                container.appendChild(l.wrapper);
                l.slider.addEventListener('input', e => { activeConfig.length = parseFloat(e.target.value); document.getElementById('length-value').textContent = activeConfig.length.toFixed(1); createHabitatShells(); });
            }
            if (shape === 'torus') {
                const tr = createSlider('torusRadius', 'Torus Radius (m)', 4, 20, activeConfig.torusRadius, 0.1);
                container.appendChild(tr.wrapper);
                tr.slider.addEventListener('input', e => { activeConfig.torusRadius = parseFloat(e.target.value); document.getElementById('torusRadius-value').textContent = activeConfig.torusRadius.toFixed(1); createHabitatShells(); });
                const tur = createSlider('tubeRadius', 'Tube Radius (m)', 1, 5, activeConfig.tubeRadius, 0.1);
                container.appendChild(tur.wrapper);
                tur.slider.addEventListener('input', e => { activeConfig.tubeRadius = parseFloat(e.target.value); document.getElementById('tubeRadius-value').textContent = activeConfig.tubeRadius.toFixed(1); createHabitatShells(); });
            }
            if (['connector', 'truss'].includes(shape)) {
                const w = createSlider('width', 'Width (m)', 2, 20, activeConfig.width, 0.1);
                container.appendChild(w.wrapper);
                w.slider.addEventListener('input', e => { activeConfig.width = parseFloat(e.target.value); document.getElementById('width-value').textContent = activeConfig.width.toFixed(1); createHabitatShells(); });
                const l = createSlider('length', 'Length (m)', 2, 20, activeConfig.length, 0.1);
                container.appendChild(l.wrapper);
                l.slider.addEventListener('input', e => { activeConfig.length = parseFloat(e.target.value); document.getElementById('length-value').textContent = activeConfig.length.toFixed(1); createHabitatShells(); });
            }
            if (['connector', 'truss', 'saucer'].includes(shape)) {
                const h = createSlider('height', 'Height (m)', 2, 10, activeConfig.height, 0.1);
                container.appendChild(h.wrapper);
                h.slider.addEventListener('input', e => { activeConfig.height = parseFloat(e.target.value); document.getElementById('height-value').textContent = activeConfig.height.toFixed(1); createHabitatShells(); });
            }
        }
        function updateSceneEnvironment() { if (missionParams.environment === 'orbit') { scene.background = scene.userData.skyboxTexture || new THREE.Color(0x111827); scene.fog = null; if(scene.children.includes(groundPlane)) scene.remove(groundPlane); if(scene.children.includes(surfaceFeatures)) scene.remove(surfaceFeatures); orbitControls.maxPolarAngle = Math.PI; } else { scene.background = new THREE.Color(0x000000); scene.fog = new THREE.FogExp2(0x935837, 0.005); if(!scene.children.includes(groundPlane)) scene.add(groundPlane); if(!scene.children.includes(surfaceFeatures)) scene.add(surfaceFeatures); orbitControls.maxPolarAngle = Math.PI / 2 - 0.05; } }
        function updateUIFromMissionParams() { document.querySelector(`input[name="environment"][value="${missionParams.environment}"]`).checked = true; updateHabitatShapeOptions(); updateSceneEnvironment(); }
        function clearAllModules() { deselectObject(); [...internalModules].forEach(module => { module.parent?.remove(module); }); internalModules.length = 0; runAnalysis(); }
        function selectObject(object) { if ((designState.designMode === 'layout' && object.userData.isModule) || (designState.designMode === 'build' && !object.userData.isModule)) { transformControls.attach(object); selectedModuleInfoEl.classList.add('hidden'); engineeringRationaleEl.classList.add('hidden'); if (object.userData.isModule) { selectedModuleInfoEl.classList.remove('hidden'); updateSelectedModuleInfo(object); } else { engineeringRationaleEl.classList.remove('hidden'); updateEngineeringRationale(object); } } }
        function deselectObject() { transformControls.detach(); selectedModuleInfoEl.classList.add('hidden'); engineeringRationaleEl.classList.add('hidden'); }
        function updateEngineeringRationale(habitatGroup) { const levelId = habitatGroup.userData.levelId; if (levelId === undefined) return; const config = levelConfigs.find(c => c.id === levelId); if(!config) return; const shapeName = scene.userData.shapeNames[config.shape] || config.shape; rationaleShapeEl.textContent = shapeName; rationaleTextEl.textContent = SHAPE_RATIONALES[config.shape] || 'No rationale available for this shape.'; }
        function deleteSelectedObject() { const selected = transformControls.object; if (!selected) return; if (selected.userData.isModule) { const index = internalModules.indexOf(selected); if (index > -1) internalModules.splice(index, 1); selected.parent?.remove(selected); deselectObject(); runAnalysis(); } }
        function toggleLinkMode() { if (designState.designMode !== 'build') { updateAlertsUI(new Set(['Switch to Build Mode to link levels.'])); setTimeout(() => runAnalysis(), 3000); return; } designState.linkMode = !designState.linkMode; designState.firstLinkLevel = null; const linkBtn = document.getElementById('link-mode-btn'); const indicator = document.getElementById('link-mode-indicator'); document.querySelectorAll('.level-btn.linking-active').forEach(b => b.classList.remove('linking-active')); if (designState.linkMode) { linkBtn.textContent = 'Cancel'; linkBtn.classList.replace('bg-yellow-600', 'bg-gray-600'); indicator.classList.remove('hidden'); deselectObject(); } else { linkBtn.textContent = 'Link Levels'; linkBtn.classList.replace('bg-gray-600', 'bg-yellow-600'); indicator.classList.add('hidden'); } }
        function handleLinkClick(levelId) { const btn = document.querySelector(`.level-btn[data-level-id="${levelId}"]`); if (designState.firstLinkLevel === null) { designState.firstLinkLevel = levelId; btn.classList.add('linking-active'); } else { if (designState.firstLinkLevel !== levelId) { linkLevels(designState.firstLinkLevel, levelId); toggleLinkMode(); } } }
        function linkLevels(parentLevelId, childLevelId) { const parentConfig = levelConfigs.find(c => c.id === parentLevelId); const childConfig = levelConfigs.find(c => c.id === childLevelId); if (!parentConfig || !childConfig || parentLevelId === childLevelId || childConfig.parent !== null) return; let current = parentConfig; while(current.parent !== null) { if (current.parent === childLevelId) return; current = levelConfigs.find(c => c.id === current.parent); } parentConfig.group.attach(childConfig.group); childConfig.parent = parentLevelId; updateConnectionsVisuals(); }
        function unlinkAllLevels() { levelConfigs.forEach(config => { if (config.parent !== null) { scene.attach(config.group); config.parent = null; } }); updateConnectionsVisuals(); }
        
        function toggleRemovalMode() {
            designState.removalMode = !designState.removalMode;
            const removeBtn = document.getElementById('remove-level-btn');
            const indicator = document.getElementById('removal-mode-indicator');
            const levelBtns = document.querySelectorAll('.level-btn');

            if (designState.removalMode) {
                removeBtn.textContent = 'Cancel';
                removeBtn.classList.replace('bg-red-800', 'bg-gray-600');
                removeBtn.classList.replace('hover:bg-red-700', 'hover:bg-gray-500');
                indicator.classList.remove('hidden');
                deselectObject();
                levelBtns.forEach(btn => btn.classList.add('removing-active'));
            } else {
                removeBtn.textContent = 'Remove Level';
                removeBtn.classList.replace('bg-gray-600', 'bg-red-800');
                removeBtn.classList.replace('hover:bg-gray-500', 'hover:bg-red-700');
                indicator.classList.add('hidden');
                levelBtns.forEach(btn => btn.classList.remove('removing-active'));
            }
        }

        function updateConnectionsVisuals() {
            connectionsGroup.clear();
            const corridorMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5568, roughness: 0.4, metalness: 0.5 });
            const flangeMaterial = new THREE.MeshStandardMaterial({ color: 0x2d3748, roughness: 0.8 });
            const connectionRaycaster = new THREE.Raycaster();

            levelConfigs.forEach(config => {
                if (config.parent !== null) {
                    const parentConfig = levelConfigs.find(c => c.id === config.parent);
                    if (parentConfig && config.group && parentConfig.group) {
                        const parentMesh = parentConfig.group.userData.shellMesh;
                        const childMesh = config.group.userData.shellMesh;
                        if (!parentMesh || !childMesh) return;
                        const center1 = new THREE.Vector3();
                        const center2 = new THREE.Vector3();
                        parentMesh.getWorldPosition(center1);
                        childMesh.getWorldPosition(center2);

                        if (center1.equals(center2)) return;

                        const directionToChild = new THREE.Vector3().subVectors(center2, center1).normalize();
                        const directionToParent = new THREE.Vector3().subVectors(center1, center2).normalize();
                        connectionRaycaster.set(center1, directionToChild);
                        const intersectsParent = connectionRaycaster.intersectObject(parentMesh);
                        const surfacePoint1 = intersectsParent.length > 0 ? intersectsParent[0].point : center1;
                        connectionRaycaster.set(center2, directionToParent);
                        const intersectsChild = connectionRaycaster.intersectObject(childMesh);
                        const surfacePoint2 = intersectsChild.length > 0 ? intersectsChild[0].point : center2;
                        const distance = surfacePoint1.distanceTo(surfacePoint2);
                        if (distance < 0.1) return;

                        const direction = new THREE.Vector3().subVectors(surfacePoint2, surfacePoint1).normalize();
                        const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);

                        const corridorRadius = 1.2;
                        const corridorGeometry = new THREE.CylinderGeometry(corridorRadius, corridorRadius, distance, 16);
                        const corridor = new THREE.Mesh(corridorGeometry, corridorMaterial);
                        corridor.position.copy(surfacePoint1).add(surfacePoint2).divideScalar(2);
                        corridor.quaternion.copy(quaternion);
                        connectionsGroup.add(corridor);
                        
                        const flangeRadius = 1.8;
                        const flangeHeight = 0.25;
                        const flangeGeometry = new THREE.CylinderGeometry(flangeRadius, flangeRadius, flangeHeight, 20);
                        const flangeOffset = flangeHeight / 2;
                        
                        const flange1 = new THREE.Mesh(flangeGeometry, flangeMaterial);
                        flange1.position.copy(surfacePoint1).addScaledVector(direction, -flangeOffset);
                        flange1.quaternion.copy(quaternion);
                        connectionsGroup.add(flange1);

                        const flange2 = new THREE.Mesh(flangeGeometry, flangeMaterial);
                        flange2.position.copy(surfacePoint2).addScaledVector(direction, flangeOffset);
                        flange2.quaternion.copy(quaternion);
                        connectionsGroup.add(flange2);
                    }
                }
            });
        }

        function runAnalysis() { let totalModuleVolume = 0; const alerts = new Set(); const presentModules = new Set(internalModules.map(m => m.userData.name)); internalModules.forEach(module => { const { name, config, volume } = module.userData; const { crewSize, duration } = missionParams; let required = config.volumePerCrew * crewSize; if(config.missionDurationFactor) { required += required * (duration / 365) * config.missionDurationFactor; } module.userData.requiredVolume = required; if (volume < required) { module.material.emissive.setHex(0xff0000); module.userData.status = 'too_small'; alerts.add(`${name} is undersized. Req: ${required.toFixed(1)} m³, Current: ${volume.toFixed(1)} m³.`); } else { module.material.emissive.setHex(0x000000); module.userData.status = 'valid'; } totalModuleVolume += volume; }); for (let i = 0; i < internalModules.length; i++) { for (let j = i + 1; j < internalModules.length; j++) { const modA = internalModules[i]; const modB = internalModules[j]; if (modA.userData.level !== modB.userData.level) continue; const boxA = new THREE.Box3().setFromObject(modA, true); const boxB = new THREE.Box3().setFromObject(modB, true); if (boxA.intersectsBox(boxB)) { alerts.add(`Overlap detected between ${modA.userData.name} and ${modB.userData.name}.`); const warningsA = modA.userData.config.adjacencyWarning || []; const warningsB = modB.userData.config.adjacencyWarning || []; if (warningsA.includes(modB.userData.name)) { alerts.add(`Zoning: ${modA.userData.name} should not be adjacent to ${modB.userData.name}.`); } if (warningsB.includes(modA.userData.name)) { alerts.add(`Zoning: ${modB.userData.name} should not be adjacent to ${modA.userData.name}.`); } } } } 
            // Space Weather Analysis: Check for Storm Shelter during active solar storms
            if (isSolarStormActive) {
                if (!presentModules.has('Storm Shelter')) {
                    alerts.add(`CRITICAL: Storm Shelter required during active solar storm events for crew radiation protection.`);
                } else {
                    // Check if storm shelter is adequately sized for crew
                    const stormShelter = internalModules.find(m => m.userData.name === 'Storm Shelter');
                    if (stormShelter) {
                        const requiredShelterVolume = MODULE_TYPES['Storm Shelter'].volumePerCrew * missionParams.crewSize;
                        if (stormShelter.userData.volume < requiredShelterVolume) {
                            alerts.add(`Storm Shelter undersized for crew of ${missionParams.crewSize}. Required: ${requiredShelterVolume.toFixed(1)} m³`);
                        }
                    }
                }
            }
            
            updateStatsUI(totalModuleVolume); updateAlertsUI(alerts); updateChecklistUI(presentModules); updateOxygenAnalysisUI(missionParams.crewSize); if (transformControls.object && transformControls.object.userData.isModule) { updateSelectedModuleInfo(transformControls.object); } }
        function updateOxygenAnalysisUI(crewSize) { const requiredOxygen = crewSize * OXYGEN_PER_PERSON_L_DAY; oxygenCrewSizeEl.textContent = crewSize; oxygenRequiredEl.textContent = `${requiredOxygen.toFixed(0)} L/day`; }
        function updateChecklistUI(presentModules) { ESSENTIAL_MODULES.forEach(name => { const li = document.getElementById(`checklist-${name.replace(/\s+/g, '-')}`); if (li) { if (presentModules.has(name)) { li.innerHTML = `<span class="mr-2">&#10004;</span> ${name}`; li.className = 'text-green-400'; } else { li.innerHTML = `<span class="mr-2">&#10008;</span> ${name}`; li.className = 'text-red-400'; } } }); }
        function updateStatsUI(totalModuleVolume) { const totalHabitatVolume = levelConfigs.reduce((sum, config) => sum + config.volume, 0); totalVolumeEl.textContent = `${totalHabitatVolume.toFixed(1)} m³`; pressurizedVolumeEl.textContent = `${(totalHabitatVolume - totalModuleVolume).toFixed(1)} m³`; modulesCountEl.textContent = internalModules.length; }
        function updateSelectedModuleInfo(module) { const { name, volume, requiredVolume, status } = module.userData; selectedModuleNameEl.textContent = name; selectedModuleVolumeEl.textContent = `${volume.toFixed(1)} m³`; selectedModuleRequiredEl.textContent = `${requiredVolume.toFixed(1)} m³`; if (status === 'valid') { selectedModuleStatusEl.textContent = 'OK'; selectedModuleStatusEl.className = 'font-bold text-green-400'; } else { selectedModuleStatusEl.textContent = 'UNDERSIZED'; selectedModuleStatusEl.className = 'font-bold text-red-400'; } }
        function updateAlertsUI(alerts) { alertsListEl.innerHTML = ''; if (alerts.size === 0) { alertsListEl.innerHTML = '<li class="text-gray-500">No alerts at this time.</li>'; } else { alerts.forEach(alertText => { const li = document.createElement('li'); li.textContent = alertText; if(alertText.startsWith('Zoning')) { li.className = 'text-yellow-400'; } else if (alertText.startsWith('Cannot') || alertText.startsWith('Maximum')) { li.className = 'text-yellow-400'; } else { li.className = 'text-red-400'; } alertsListEl.appendChild(li); }); } }
        
        init();
    </script>
</body>
</html>

